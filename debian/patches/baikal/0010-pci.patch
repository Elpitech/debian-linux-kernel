diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index 423d35872ce..16dda4a804a 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -82,6 +82,17 @@ config PCIE_DW_PLAT_EP
 	  order to enable device-specific features PCI_DW_PLAT_EP must be
 	  selected.
 
+config PCIE_BAIKAL
+	tristate "Baikal SoC PCIe controller"
+	depends on ARCH_BAIKAL
+	depends on OF && HAS_IOMEM
+	depends on PCI_MSI_IRQ_DOMAIN
+	select PCIE_DW_HOST
+	help
+	  Enables support for the PCIe controller in the Baikal SoC.  There
+	  are three instances of PCIe controller in Baikal-M.  Two of the controllers
+	  support PCIe 3.0 x4 and the remaining one supports PCIe 3.0 x8.
+
 config PCI_EXYNOS
 	tristate "Samsung Exynos PCIe controller"
 	depends on ARCH_EXYNOS || COMPILE_TEST
diff --git a/drivers/pci/controller/dwc/Makefile b/drivers/pci/controller/dwc/Makefile
index 9e6ce0dc2f5..d3c221d735c 100644
--- a/drivers/pci/controller/dwc/Makefile
+++ b/drivers/pci/controller/dwc/Makefile
@@ -3,6 +3,7 @@ obj-$(CONFIG_PCIE_DW) += pcie-designware.o
 obj-$(CONFIG_PCIE_DW_HOST) += pcie-designware-host.o
 obj-$(CONFIG_PCIE_DW_EP) += pcie-designware-ep.o
 obj-$(CONFIG_PCIE_DW_PLAT) += pcie-designware-plat.o
+obj-$(CONFIG_PCIE_BAIKAL) += pcie-baikal.o
 obj-$(CONFIG_PCI_DRA7XX) += pci-dra7xx.o
 obj-$(CONFIG_PCI_EXYNOS) += pci-exynos.o
 obj-$(CONFIG_PCIE_FU740) += pcie-fu740.o
diff --git a/drivers/pci/controller/dwc/pcie-baikal.c b/drivers/pci/controller/dwc/pcie-baikal.c
new file mode 100644
index 00000000000..dc597718b20
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-baikal.c
@@ -0,0 +1,552 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * pcie-baikal - PCIe controller driver for Baikal SoCs
+ *
+ * Copyright (C) 2019 Baikal Electronics JSC
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irqchip/arm-gic-v3.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/baikal/lcru-pcie.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pci.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/ratelimit.h>
+
+#include "pcie-designware.h"
+
+struct baikal_pcie {
+	struct dw_pcie *pci;
+	unsigned bus_nr;
+	struct regmap *lcru;
+	struct gpio_desc *reset_gpio;
+	char reset_name[32];
+};
+
+#define to_baikal_pcie(x)	dev_get_drvdata((x)->dev)
+
+#define LINK_RETRAIN_TIMEOUT HZ
+
+/* Baikal (DesignWare) specific registers. */
+#define PCIE_COHERENCE_CONTROL_3_OFF	(0x8e8) /* to set cache coherence register. */
+
+/* Error registers in capabilities config space block */
+#define PCI_DEV_CTRL_STAT		0x78
+#define PCI_ROOT_CTRL_CAP		0x8c
+#define PCI_UNCORR_ERR_STAT		0x104
+#define PCI_UNCORR_ERR_MASK		0x10c
+#define PCI_CORR_ERR_STAT		0x110
+#define PCI_CORR_ERR_MASK		0x114
+#define PCI_ROOT_ERR_CMD		0x12c
+#define PCI_ROOT_ERR_STAT		0x130
+#define PCI_ROOT_ERR_SRC_ID		0x134
+
+#define PCIE_LINK_CAPABILITIES_REG		(0x7c)	/* Link Capabilities Register. */
+
+#define PCIE_LINK_CONTROL_LINK_STATUS_REG	(0x80)	/* Link Control and Status Register. */
+/* LINK_CONTROL_LINK_STATUS_REG */
+#define PCIE_CAP_LINK_SPEED_SHIFT		16
+#define PCIE_CAP_LINK_SPEED_MASK		0xF0000
+#define PCIE_CAP_LINK_SPEED_GEN1		0x1
+#define PCIE_CAP_LINK_SPEED_GEN2		0x2
+#define PCIE_CAP_LINK_SPEED_GEN3		0x3
+#define PCIE_STA_LINK_TRAINING			0x8000000
+#define PCIE_STA_LINK_WIDTH_MASK		0x3f00000
+#define PCIE_STA_LINK_WIDTH_SHIFT		(20)
+
+#define PCIE_LINK_CONTROL2_LINK_STATUS2_REG	(0xa0)	/* Link Control 2 and Status 2 Register. */
+/* PCIE_LINK_CONTROL2_LINK_STATUS2 */
+#define PCIE_LINK_CONTROL2_GEN_MASK		(0xF)
+
+static int baikal_pcie_link_up(struct dw_pcie *pci);
+
+static inline int baikal_pcie_link_is_training(struct dw_pcie *pci)
+{
+	int reg = dw_pcie_readl_dbi(pci, PCIE_LINK_CONTROL_LINK_STATUS_REG);
+
+	return reg & PCIE_STA_LINK_TRAINING;
+}
+
+static bool baikal_wait_pcie_link_training_done(struct dw_pcie *pci)
+{
+	unsigned long start_jiffies = jiffies;
+
+	while (baikal_pcie_link_is_training(pci)) {
+		if (time_after(jiffies, start_jiffies + LINK_RETRAIN_TIMEOUT)) {
+			pr_err("%s: link retrained for too long, timeout occured\n", __func__);
+			return false;
+		}
+		usleep_range(800, 1000);
+	}
+	return true;
+}
+
+static inline void baikal_pcie_link_retrain(struct dw_pcie *pci, int target_speed)
+{
+	int reg;
+	unsigned long start_jiffies;
+
+	/* In case link is already training wait for training to complete */
+	baikal_wait_pcie_link_training_done(pci);
+
+	/* Set desired speed */
+	reg = dw_pcie_readl_dbi(pci, PCIE_LINK_CONTROL2_LINK_STATUS2_REG);
+	reg &= ~PCIE_LINK_CONTROL2_GEN_MASK;
+	reg |= target_speed;
+	dw_pcie_writel_dbi(pci, PCIE_LINK_CONTROL2_LINK_STATUS2_REG, reg);
+
+	/* Set Retrain Link bit */
+	reg = dw_pcie_readl_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL);
+	reg |= PORT_LOGIC_SPEED_CHANGE;
+	dw_pcie_writel_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL, reg);
+
+	/* Wait for link training end */
+	if (!baikal_wait_pcie_link_training_done(pci))
+		return;
+
+	start_jiffies = jiffies;
+	while (baikal_pcie_link_up(pci) == 0) {
+		if (time_after(jiffies, start_jiffies + LINK_RETRAIN_TIMEOUT)) {
+			pr_err("%s: link retrained for too long, timeout occured\n", __func__);
+			break;
+		}
+		usleep_range(8000, 10000);
+	}
+}
+
+static int baikal_pcie_link_up(struct dw_pcie *pci)
+{
+	struct baikal_pcie *rc = to_baikal_pcie(pci);
+	u32 reg;
+
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+	if (!(reg & BAIKAL_PCIE_LTSSM_ENABLE))
+		return 0;
+
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_STATUS(rc->bus_nr));
+	reg &= BAIKAL_PCIE_RDLH_LINKUP | BAIKAL_PCIE_SMLH_LINKUP |
+	       BAIKAL_PCIE_LTSSM_STATE_MASK;
+	if (reg == (BAIKAL_PCIE_RDLH_LINKUP | BAIKAL_PCIE_SMLH_LINKUP |
+		    BAIKAL_PCIE_LTSSM_STATE_L0))
+		return 1; /* Link is up */
+
+	return 0;
+}
+
+static int baikal_pcie_establish_link(struct dw_pcie *pci)
+{
+	u32 reg;
+	int speed, target_speed;
+	int ret;
+
+	ret = dw_pcie_wait_for_link(pci);
+	if (ret != 0)
+		return ret;
+
+	reg = dw_pcie_readl_dbi(pci, PCIE_LINK_CONTROL_LINK_STATUS_REG);
+	speed = (reg & PCIE_CAP_LINK_SPEED_MASK) >> PCIE_CAP_LINK_SPEED_SHIFT;
+	while (speed < PCIE_CAP_LINK_SPEED_GEN3) {
+		target_speed = speed + 1;
+		dev_info(pci->dev, "Retrain link to Gen%d...\n", target_speed);
+		baikal_pcie_link_retrain(pci, target_speed);
+		reg = dw_pcie_readl_dbi(pci, PCIE_LINK_CONTROL_LINK_STATUS_REG);
+		speed = (reg & PCIE_CAP_LINK_SPEED_MASK) >>
+				PCIE_CAP_LINK_SPEED_SHIFT;
+		if (speed < target_speed)
+			break; /* give up */
+	}
+	dev_info(pci->dev, "Link Status is Gen%d, x%d\n", speed,
+		 (reg & PCIE_STA_LINK_WIDTH_MASK) >>
+			PCIE_STA_LINK_WIDTH_SHIFT);
+
+	return ret;
+}
+
+static int baikal_pcie_host_init(struct pcie_port *pp)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct baikal_pcie *baikal_pcie = to_baikal_pcie(pci);
+	u32 lcru_reg, class_reg, reg;
+	int i;
+
+	/* Deconfigure all ATU regions - god knows what has uefi set them to */
+	for (i = 0; i < pci->num_ob_windows; i++) {
+		dw_pcie_writel_dbi(pci, PCIE_ATU_VIEWPORT,
+				   PCIE_ATU_REGION_OUTBOUND | i);
+		dw_pcie_writel_dbi(pci, PCIE_ATU_CR2, 0);
+	}
+
+	// Set class
+	lcru_reg = baikal_pcie_lcru_readl(baikal_pcie->lcru,
+				BAIKAL_LCRU_PCIE_GEN_CTL(baikal_pcie->bus_nr));
+	baikal_pcie_lcru_writel(baikal_pcie->lcru,
+				BAIKAL_LCRU_PCIE_GEN_CTL(baikal_pcie->bus_nr),
+				lcru_reg & (~BAIKAL_PCIE_DBI2_MODE));
+
+	dw_pcie_dbi_ro_wr_en(pci);
+	class_reg = dw_pcie_readl_dbi(pci, PCI_CLASS_REVISION);
+
+	class_reg = (PCI_CLASS_BRIDGE_PCI << 16) | (1 << 8) | (class_reg & 0xff);
+	// class PCI_PCI_BRIDGE=0x604, prog-if=1
+	dw_pcie_writel_dbi(pci, PCI_CLASS_REVISION, class_reg);
+
+	dw_pcie_dbi_ro_wr_dis(pci);
+
+	baikal_pcie_establish_link(pci);
+
+	dw_pcie_setup_rc(pp);
+
+	dw_pcie_writel_dbi(pci, PCI_ROOT_ERR_CMD, 7); // enable AER
+	reg = dw_pcie_readl_dbi(pci, PCI_DEV_CTRL_STAT);
+	reg |= 0xf; // enable error reporting
+	dw_pcie_writel_dbi(pci, PCI_DEV_CTRL_STAT, reg);
+	reg = dw_pcie_readl_dbi(pci, PCI_ROOT_CTRL_CAP);
+	reg |= 0xf; // enable error reporting
+	dw_pcie_writel_dbi(pci, PCI_ROOT_CTRL_CAP, reg);
+
+	return 0;
+}
+
+static int baikal_pcie_msi_host_init(struct pcie_port *pp)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct device *dev = pci->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *msi_node;
+
+	/*
+	 * The MSI domain is set by the generic of_msi_configure().  This
+	 * .msi_host_init() function keeps us from doing the default MSI
+	 * domain setup in dw_pcie_host_init() and also enforces the
+	 * requirement that "msi-parent" exists.
+	 */
+	msi_node = of_parse_phandle(np, "msi-parent", 0);
+	if (!msi_node) {
+		dev_warn(dev, "failed to find msi-parent\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct dw_pcie_host_ops baikal_pcie_host_ops = {
+	.host_init = baikal_pcie_host_init,
+	.msi_host_init = baikal_pcie_msi_host_init,
+};
+
+static const struct dw_pcie_ops baikal_pcie_ops = {
+	.link_up = baikal_pcie_link_up,
+};
+
+DEFINE_RATELIMIT_STATE(pcie_err_printk_ratelimit, 300 * HZ, 10);
+
+static irqreturn_t baikal_pcie_err_irq_handler(int irq, void *priv)
+{
+	struct baikal_pcie *rc = priv;
+	struct dw_pcie *pci = rc->pci;
+	struct device *dev = pci->dev;
+	u32 ue_st, ce_st, r_st, dev_st;
+
+	ue_st = dw_pcie_readl_dbi(pci, PCI_UNCORR_ERR_STAT);
+	ce_st = dw_pcie_readl_dbi(pci, PCI_CORR_ERR_STAT);
+	r_st = dw_pcie_readl_dbi(pci, PCI_ROOT_ERR_STAT);
+	dev_st = dw_pcie_readl_dbi(pci, PCI_DEV_CTRL_STAT);
+
+	if (__ratelimit(&pcie_err_printk_ratelimit)) {
+		if (r_st & 0x7c) {
+			if (r_st & 0x58)
+				dev_err(dev, "%sFatal Error: %x\n",
+					(r_st & 0x8) ? "Multiple " : "", ue_st);
+			else
+				dev_err(dev, "%sNon-Fatal Error: %x\n",
+					(r_st & 8) ? "Multiple " : "", ue_st);
+		}
+
+		if (r_st & 3)
+			dev_err(dev, "%sCorrectable Error: %x\n",
+				(r_st & 2) ? "Multiple " : "", ce_st);
+
+		if (dev_st & 0xf0000)
+			dev_err(dev, "Device Status Errors: %x\n", dev_st >> 16);
+	}
+
+	dw_pcie_writel_dbi(pci, PCI_UNCORR_ERR_STAT, ue_st);
+	dw_pcie_writel_dbi(pci, PCI_CORR_ERR_STAT, ce_st);
+	dw_pcie_writel_dbi(pci, PCI_ROOT_ERR_STAT, r_st);
+	dw_pcie_writel_dbi(pci, PCI_DEV_CTRL_STAT, dev_st);
+
+	return IRQ_HANDLED;
+}
+
+static int baikal_add_pcie_port(struct baikal_pcie *rc,
+				       struct platform_device *pdev)
+{
+	struct dw_pcie *pci = rc->pci;
+	struct pcie_port *pp = &pci->pp;
+	struct resource *res;
+	int irq;
+	int ret;
+
+	pci->dev = &pdev->dev;
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dbi");
+	if (res) {
+		pci->dbi_base = devm_ioremap_resource(pci->dev, res);
+		if (IS_ERR(pci->dbi_base)) {
+			dev_err(pci->dev, "error with ioremap\n");
+			return PTR_ERR(pci->dbi_base);
+		}
+	} else {
+		dev_err(pci->dev, "missing *dbi* reg space\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(pci->dev, "missing IRQ resource: %d\n", irq);
+		return irq;
+	}
+
+	ret = devm_request_irq(pci->dev, irq, baikal_pcie_err_irq_handler, IRQF_SHARED,
+			"baikal-pcie-error-irq", rc);
+	if (ret < 0) {
+		dev_err(pci->dev, "failed to request error IRQ %d\n",
+			irq);
+		return ret;
+	}
+
+	pp->ops = &baikal_pcie_host_ops;
+
+	ret = dw_pcie_host_init(pp);
+	if (ret) {
+		dev_err(pci->dev, "failed to initialize host\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int baikal_pcie_hw_init_m(struct baikal_pcie *rc)
+{
+	u32 reg;
+
+	/* Cease link */
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+	reg &= ~BAIKAL_PCIE_LTSSM_ENABLE;
+	baikal_pcie_lcru_writel(rc->lcru, BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr), reg);
+
+	/* Force controller reset */
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_RESET(rc->bus_nr));
+	reg |= BAIKAL_PCIE_PWR_RST | BAIKAL_PCIE_CORE_RST |
+	       BAIKAL_PCIE_PIPE_RESET | BAIKAL_PCIE_PHY_RESET;
+	baikal_pcie_lcru_writel(rc->lcru, BAIKAL_LCRU_PCIE_RESET(rc->bus_nr), reg);
+
+	/* Wait */
+	usleep_range(80000, 100000);
+
+	/* Deassert PHY reset */
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_RESET(rc->bus_nr));
+	reg &= ~BAIKAL_PCIE_PHY_RESET;
+	baikal_pcie_lcru_writel(rc->lcru, BAIKAL_LCRU_PCIE_RESET(rc->bus_nr), reg);
+
+	/* Enable access to the PHY registers */
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+	reg |= BAIKAL_PCIE_PHY_MGMT_ENABLE;
+	baikal_pcie_lcru_writel(rc->lcru, BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr), reg);
+
+	/* Clear all software controlled resets of the controller */
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_RESET(rc->bus_nr));
+	reg &= ~(BAIKAL_PCIE_ADB_PWRDWN | BAIKAL_PCIE_HOT_RESET |
+		 BAIKAL_PCIE_NONSTICKY_RST | BAIKAL_PCIE_STICKY_RST |
+		 BAIKAL_PCIE_PWR_RST | BAIKAL_PCIE_CORE_RST |
+		 BAIKAL_PCIE_PIPE_RESET | BAIKAL_PCIE_PIPE1_RESET);
+	baikal_pcie_lcru_writel(rc->lcru, BAIKAL_LCRU_PCIE_RESET(rc->bus_nr), reg);
+
+	/* Start LTSSM */
+	reg = baikal_pcie_lcru_readl(rc->lcru, BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+	reg |= BAIKAL_PCIE_LTSSM_ENABLE;
+	baikal_pcie_lcru_writel(rc->lcru, BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr), reg);
+
+	return 0;
+}
+
+static const struct of_device_id of_baikal_pcie_match[] = {
+	{ .compatible = "baikal,pcie-m", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_baikal_pcie_match);
+
+static int baikal_pcie_probe(struct platform_device *pdev)
+{
+	struct dw_pcie *pci;
+	struct baikal_pcie *pcie;
+	struct device *dev = &pdev->dev;
+	int err;
+	u32 index[2];
+	enum of_gpio_flags flags;
+	int reset_gpio;
+	u32 reg;
+	int link_up = 0;
+
+	pcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);
+	if (!pcie) {
+		dev_err(dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	pci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);
+	if (!pci) {
+		dev_err(dev, "failed to allocate memory [2]\n");
+		return -ENOMEM;
+	}
+	pci->dev = dev;
+	pci->ops = &baikal_pcie_ops;
+
+	pcie->pci = pci;
+
+	pcie->lcru = syscon_regmap_lookup_by_phandle(dev->of_node,
+					"baikal,pcie-lcru");
+	if (IS_ERR(pcie->lcru)) {
+		dev_err(dev, "No LCRU phandle specified\n");
+		pcie->lcru = NULL;
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(dev->of_node,
+			"baikal,pcie-lcru", index, 2)) {
+		dev_err(dev, "failed to read LCRU\n");
+		pcie->lcru = NULL;
+		return -EINVAL;
+	}
+	pcie->bus_nr = index[1];
+
+	pm_runtime_enable(dev);
+	err = pm_runtime_get_sync(dev);
+	if (err < 0) {
+		dev_err(dev, "pm_runtime_get_sync failed\n");
+		goto err_pm_disable;
+	}
+
+	reg = baikal_pcie_lcru_readl(pcie->lcru, BAIKAL_LCRU_PCIE_STATUS(pcie->bus_nr));
+	dev_dbg(dev, "%s: bus %d - link state %x, reset %x\n",
+		__func__, pcie->bus_nr, reg,
+		baikal_pcie_lcru_readl(pcie->lcru, BAIKAL_LCRU_PCIE_RESET(pcie->bus_nr)));
+	if ((reg & (BAIKAL_PCIE_RDLH_LINKUP | BAIKAL_PCIE_SMLH_LINKUP)) ==
+	    (BAIKAL_PCIE_RDLH_LINKUP | BAIKAL_PCIE_SMLH_LINKUP)) {
+		link_up = 1;
+	}
+	reset_gpio = of_get_named_gpio_flags(dev->of_node, "reset-gpios", 0, &flags);
+	if (gpio_is_valid(reset_gpio)) {
+		unsigned long gpio_flags;
+
+		snprintf(pcie->reset_name, 32, "pcie%d-reset", pcie->bus_nr);
+		/* gpio_flags correspond to "reset" state */
+		if (flags & OF_GPIO_ACTIVE_LOW)
+			gpio_flags = GPIOF_ACTIVE_LOW | GPIOF_OUT_INIT_LOW;
+		else
+			gpio_flags = GPIOF_OUT_INIT_HIGH;
+
+		/*
+		 * if link was up then we do not perform reset and request gpio
+		 * in "non-reset" state
+		 */
+		if (link_up)
+			gpio_flags ^= GPIOF_OUT_INIT_HIGH ^ GPIOF_OUT_INIT_LOW;
+		err = devm_gpio_request_one(dev, reset_gpio, gpio_flags,
+					    pcie->reset_name);
+		if (err) {
+			dev_err(dev, "request GPIO failed (%d)\n", err);
+			goto err_pm_disable;
+		}
+		pcie->reset_gpio = gpio_to_desc(reset_gpio);
+
+	} else if (reset_gpio == -EPROBE_DEFER) {
+		err = reset_gpio;
+		goto err_pm_disable;
+	}
+
+	if (!link_up) {
+		baikal_pcie_hw_init_m(pcie);
+		if (pcie->reset_gpio)
+			gpiod_set_value_cansleep(pcie->reset_gpio, 0);
+	}
+
+	platform_set_drvdata(pdev, pcie);
+
+	err = baikal_add_pcie_port(pcie, pdev);
+	if (!err)
+		return 0;
+
+	pm_runtime_put(dev);
+
+err_pm_disable:
+	pm_runtime_disable(dev);
+
+	return err;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int baikal_pcie_suspend(struct device *dev)
+{
+	struct baikal_pcie *rc = dev_get_drvdata(dev);
+	struct dw_pcie *pci = rc->pci;
+	u32 val;
+
+	/* clear MSE */
+	val = dw_pcie_readl_dbi(pci, PCI_COMMAND);
+	val &= ~PCI_COMMAND_MEMORY;
+	dw_pcie_writel_dbi(pci, PCI_COMMAND, val);
+
+	return 0;
+}
+
+static int baikal_pcie_resume(struct device *dev)
+{
+	struct baikal_pcie *rc = dev_get_drvdata(dev);
+	struct dw_pcie *pci = rc->pci;
+	u32 val;
+
+	/* set MSE */
+	val = dw_pcie_readl_dbi(pci, PCI_COMMAND);
+	val |= PCI_COMMAND_MEMORY;
+	dw_pcie_writel_dbi(pci, PCI_COMMAND, val);
+
+	return 0;
+}
+
+static int baikal_pcie_suspend_noirq(struct device *dev)
+{
+	return 0;
+}
+
+static int baikal_pcie_resume_noirq(struct device *dev)
+{
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops baikal_pcie_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(baikal_pcie_suspend, baikal_pcie_resume)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(baikal_pcie_suspend_noirq,
+				      baikal_pcie_resume_noirq)
+};
+
+static struct platform_driver baikal_pcie_driver = {
+	.driver = {
+		.name	= "baikal-pcie",
+		.of_match_table = of_baikal_pcie_match,
+		.suppress_bind_attrs = true,
+		.pm	= &baikal_pcie_pm_ops,
+	},
+	.probe = baikal_pcie_probe,
+};
+
+builtin_platform_driver(baikal_pcie_driver);
+
+MODULE_DESCRIPTION("Baikal PCIe host controller driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/mfd/baikal/lcru-pcie.h b/include/linux/mfd/baikal/lcru-pcie.h
new file mode 100644
index 00000000000..d936759c040
--- /dev/null
+++ b/include/linux/mfd/baikal/lcru-pcie.h
@@ -0,0 +1,142 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Baikal SoC series Local Clock and Reset Unit (LCRU) register offsets
+ * and bit definitions.
+ *
+ * Copyright (C) 2019 Baikal Electronics JSC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_MFD_SYSCON_BAIKAL_LCRU_H_
+#define _LINUX_MFD_SYSCON_BAIKAL_LCRU_H_
+
+#include <linux/regmap.h>
+
+//#define BAIKAL_CMU_PCIE_STEP	0x30
+
+//#define BAIKAL_CMU_PCIE_MSTRCLK	0x20
+//#define BAIKAL_CMU_PCIE_SLVCLK	0x30
+//#define BAIKAL_CMU_PCIE_CFGCLK	0x40
+
+#define BAIKAL_LCRU_PCIE_RESET_BASE		0x50000		/* GPR0_RW */
+#define BAIKAL_LCRU_PCIE_RESET(x)		((x * 0x20) + BAIKAL_LCRU_PCIE_RESET_BASE)
+#define BAIKAL_PCIE_ADB_PWRDWN			(1 << 13)
+#define BAIKAL_PCIE_HOT_RESET			(1 << 12)
+#define BAIKAL_PCIE_NONSTICKY_RST		(1 << 11)
+#define BAIKAL_PCIE_STICKY_RST			(1 << 10)
+#define BAIKAL_PCIE_PWR_RST				(1 << 9)
+#define BAIKAL_PCIE_CORE_RST			(1 << 8)
+#define BAIKAL_PCIE_PIPE1_RESET			(1 << 5) /* x8 controller only */
+#define BAIKAL_PCIE_PIPE0_RESET			(1 << 4) /* x8 controller only */
+#define BAIKAL_PCIE_PIPE_RESET			(1 << 4) /* x4 controllers only */
+#define BAIKAL_PCIE_PHY_RESET			(1 << 0)
+
+#define BAIKAL_LCRU_PCIE_STATUS_BASE	0x50004		/* GPR0_RO */
+#define BAIKAL_LCRU_PCIE_STATUS(x)		((x * 0x20) + BAIKAL_LCRU_PCIE_STATUS_BASE)
+#define BAIKAL_PCIE_TURNOFF_ACK			(1 << 31)
+#define BAIKAL_PCIE_ADB_PWRACK			(1 << 30)
+#define BAIKAL_PCIE_WAKE_DET			(1 << 24)
+#define BAIKAL_PCIE_AUX_PM_EN			(1 << 22)
+#define BAIKAL_PCIE_PM_PME_STATUS		(1 << 21)
+#define BAIKAL_PCIE_PM_PME_EN			(1 << 20)
+#define BAIKAL_PCIE_PM_DSTATE_SHIFT		16
+#define BAIKAL_PCIE_PM_DSTATE_MASK		0x7
+#define BAIKAL_PCIE_PM_DSTATE_D0		0
+#define BAIKAL_PCIE_PM_DSTATE_D1		1
+#define BAIKAL_PCIE_PM_DSTATE_D2		2
+#define BAIKAL_PCIE_PM_DSTATE_D3		3
+#define BAIKAL_PCIE_PM_DSTATE_UNINIT	4
+#define BAIKAL_PCIE_LTSSM_RCVRY_EQ		(1 << 15)
+#define BAIKAL_PCIE_PIPE_CLK_REQ		(1 << 14)
+#define BAIKAL_PCIE_SMLH_REQ_RST		(1 << 13)
+#define BAIKAL_PCIE_LINK_REQ_RST		(1 << 12)
+#define BAIKAL_PCIE_PM_LINKSTATE_L2		(1 << 10)
+#define BAIKAL_PCIE_PM_LINKSTATE_L1		(1 << 9)
+#define BAIKAL_PCIE_PM_LINKSTATE_L0S	(1 << 8)
+#define BAIKAL_PCIE_RDLH_LINKUP			(1 << 7)
+#define BAIKAL_PCIE_SMLH_LINKUP			(1 << 6)
+#define BAIKAL_PCIE_LTSSM_STATE_SHIFT					0
+#define BAIKAL_PCIE_LTSSM_STATE_MASK					0x3F
+#define BAIKAL_PCIE_LTSSM_STATE_DETECT_QUIET			0x00
+#define BAIKAL_PCIE_LTSSM_STATE_DETECT_ACT				0x01
+#define BAIKAL_PCIE_LTSSM_STATE_POLLING_ACTIVE			0x02
+#define BAIKAL_PCIE_LTSSM_STATE_POLLING_COMPLIANCE		0x03
+#define BAIKAL_PCIE_LTSSM_STATE_POLLING_CONFIG			0x04
+#define BAIKAL_PCIE_LTSSM_STATE_PRE_DETECT_QUIET		0x05
+#define BAIKAL_PCIE_LTSSM_STATE_DETECT_WAIT				0x06
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LINK_WD_START		0x07
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LINK_WD_ACCEPT		0x08
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LANE_NUM_WAIT		0x09
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LANE_NUM_ACCEPT		0x0A
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_COMPLETE			0x0B
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_IDLE				0x0C
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_LOCK				0x0D
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_SPEED				0x0E
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_RCVR_CFG			0x0F
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_IDLE				0x10
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ0				0x20
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ1				0x21
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ2				0x22
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ3				0x23
+#define BAIKAL_PCIE_LTSSM_STATE_L0						0x11
+#define BAIKAL_PCIE_LTSSM_STATE_L0S						0x12
+#define BAIKAL_PCIE_LTSSM_STATE_L123_SEND_IDLE			0x13
+#define BAIKAL_PCIE_LTSSM_STATE_L1_IDLE					0x14
+#define BAIKAL_PCIE_LTSSM_STATE_L2_IDLE					0x15
+#define BAIKAL_PCIE_LTSSM_STATE_L2_WAKE					0x16
+#define BAIKAL_PCIE_LTSSM_STATE_DISABLED_ENTRY			0x17
+#define BAIKAL_PCIE_LTSSM_STATE_DISABLED_IDLE			0x18
+#define BAIKAL_PCIE_LTSSM_STATE_DISABLED				0x19
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_ENTRY			0x1A
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_ACTIVE			0x1B
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_EXIT			0x1C
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_EXIT_TIMEOUT	0x1D
+#define BAIKAL_PCIE_LTSSM_STATE_HOT_RESET_ENTRY			0x1E
+#define BAIKAL_PCIE_LTSSM_STATE_HOT_RESET				0x1F
+
+#define BAIKAL_LCRU_PCIE_GEN_CTL_BASE		0x50008		/* GPR1_RW*/
+#define BAIKAL_LCRU_PCIE_GEN_CTL(x)			((x * 0x20) + BAIKAL_LCRU_PCIE_GEN_CTL_BASE)
+#define BAIKAL_PCIE_AUX_PWR_DET				(1 << 24)
+#define BAIKAL_PCIE_TXLANE_FLIP_EN			(1 << 17)
+#define BAIKAL_PCIE_RXLANE_FLIP_EN			(1 << 16)
+#define BAIKAL_PCIE_PHY_MGMT_ENABLE			(1 << 3)
+#define BAIKAL_PCIE_DBI2_MODE				(1 << 2)
+#define BAIKAL_PCIE_LTSSM_ENABLE			(1 << 1)
+
+#define BAIKAL_LCRU_PCIE_POWER_CTL_BASE		0x50010		/* GPR2_RW */
+#define BAIKAL_LCRU_PCIE_POWER_CTL(x)		((x * 0x20) + BAIKAL_LCRU_POWER_CTL_BASE)
+#define BAIKAL_PCIE_PHY_CLK_REQ				(1 << 27)
+#define BAIKAL_PCIE_APP_CLK_REQ				(1 << 26)
+#define BAIKAL_PCIE_PERSTN					(1 << 25)
+#define BAIKAL_PCIE_TURNOFF_REQ				(1 << 24)
+#define BAIKAL_PCIE_REQ_EXIT_L1				(1 << 17)
+#define BAIKAL_PCIE_L1_PENDING				(1 << 16)
+#define BAIKAL_PCIE_MAC_CLK_REQ				(1 << 5)
+#define BAIKAL_PCIE_PCS_CLK_REQ				(1 << 4)
+
+#define BAIKAL_LCRU_PCIE_MSI_TRANS_CTL0		0x500E8
+#define BAIKAL_PCIE_MSI_AWUSER_SHIFT		0
+#define BAIKAL_PCIE_MSI_AWUSER_MASK			0xF
+
+#define BAIKAL_LCRU_PCIE_MSI_TRANS_CTL2		0x500F8
+#define BAIKAL_PCIE_MSI_TRANS_EN(x)			(1 << (9 + (x)))
+#define BAIKAL_PCIE_MSI_RCNUM(x)			((x) << (2 * (x)))
+#define BAIKAL_PCIE_MSI_RCNUM_MASK(x)		(0x3 << (2 * (x)))
+
+inline u32 baikal_pcie_lcru_readl(struct regmap *lcru, u32 offset)
+{
+	u32 val;
+
+	regmap_read(lcru, offset, &val);
+	return val;
+}
+
+inline void baikal_pcie_lcru_writel(struct regmap *lcru, u32 offset, u32 val)
+{
+	regmap_write(lcru, offset, val);
+}
+
+#endif /* _LINUX_MFD_SYSCON_BAIKAL_LCRU_H_ */
