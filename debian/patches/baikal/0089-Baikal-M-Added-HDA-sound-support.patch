From d52ccb8a5fd1e86d6be8bd15351c14971f4b39fe Mon Sep 17 00:00:00 2001
From: Vitaly Miniakhmetov <vitaliy.miniakhmetov@elpitech.ru>
Date: Fri, 1 Oct 2021 00:32:09 +0500
Subject: [PATCH 089/106] Baikal-M: Added HDA sound support

---
 arch/arm64/boot/dts/baikal/bm-clocks.dtsi     |   6 +-
 arch/arm64/boot/dts/baikal/bm-dbm.dts         |   4 +
 arch/arm64/boot/dts/baikal/bm-mbm.dtsi        |   4 +
 arch/arm64/boot/dts/baikal/bm-soc.dtsi        |   9 +
 arch/arm64/configs/baikal_defconfig           |  19 +-
 .../configs/edelweiss_e107_mb_a0_defconfig    |   2 +
 .../configs/edelweiss_tf307_mb_d_defconfig    |   2 +
 .../configs/elpitech_et101_mb_a1_a2_defconfig |   2 +
 arch/arm64/configs/tp_baikal_defconfig        |   2 +-
 sound/hda/hdac_controller.c                   |  15 +
 sound/pci/hda/Kconfig                         |  13 +
 sound/pci/hda/Makefile                        |   2 +
 sound/pci/hda/hda_baikal.c                    | 525 ++++++++++++++++++
 sound/pci/hda/hda_controller.c                |  57 +-
 14 files changed, 630 insertions(+), 32 deletions(-)
 create mode 100644 sound/pci/hda/hda_baikal.c

diff --git a/arch/arm64/boot/dts/baikal/bm-clocks.dtsi b/arch/arm64/boot/dts/baikal/bm-clocks.dtsi
index 38946f3d6c10..0b9c159e5bfc 100644
--- a/arch/arm64/boot/dts/baikal/bm-clocks.dtsi
+++ b/arch/arm64/boot/dts/baikal/bm-clocks.dtsi
@@ -85,6 +85,8 @@ cmu0_avlsp: cmu0_avlsp {
 			"dmac",		// <12>
 			"smbus1",	// <13>
 			"smbus2",	// <14>
+			"hda_sys_clk",  // <15>
+			"hda_clk48",    // <16>
 			"mshc_axi",	// <17>
 			"mshc_ahb",	// <18>
 			"mshc_tx_x2",	// <19>
@@ -97,8 +99,8 @@ cmu0_avlsp: cmu0_avlsp {
 			"vdu_axi",	// <26>
 			"smmu";		// <27>
 		clock-indices =
-			<0>, <1>, <2>, <3>, <4>, <5>, <6>, <7>, <8>, <9>,
-			<10>, <11>, <12>, <13>, <14>, <17>, <18>, <19>,
+			<0>, <1>, <2>, <3>, <4>, <5>, <6>, <7>, <8>, <9>, <10>,
+			<11>, <12>, <13>, <14>, <15>, <16>, <17>, <18>, <19>,
 			<20>, <21>, <22>, <23>, <24>, <25>, <26>, <27>;
 		clocks = <&osc25>;
 		cmu-id = <0x20000000>;
diff --git a/arch/arm64/boot/dts/baikal/bm-dbm.dts b/arch/arm64/boot/dts/baikal/bm-dbm.dts
index 23c2c8d217e8..0f68c88f5028 100644
--- a/arch/arm64/boot/dts/baikal/bm-dbm.dts
+++ b/arch/arm64/boot/dts/baikal/bm-dbm.dts
@@ -111,6 +111,10 @@ &gpu {
 	system-coherency = <0>;
 };
 
+&hda {
+	status = "okay";
+};
+
 &hdmi {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/baikal/bm-mbm.dtsi b/arch/arm64/boot/dts/baikal/bm-mbm.dtsi
index 08d2c5002b5c..4a39009a4d42 100644
--- a/arch/arm64/boot/dts/baikal/bm-mbm.dtsi
+++ b/arch/arm64/boot/dts/baikal/bm-mbm.dtsi
@@ -56,6 +56,10 @@ &gpu {
 	system-coherency = <0>;
 };
 
+&hda {
+	status = "okay";
+};
+
 &hdmi {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/baikal/bm-soc.dtsi b/arch/arm64/boot/dts/baikal/bm-soc.dtsi
index 6cf022242f75..c9cabd5999d7 100644
--- a/arch/arm64/boot/dts/baikal/bm-soc.dtsi
+++ b/arch/arm64/boot/dts/baikal/bm-soc.dtsi
@@ -34,6 +34,7 @@ aliases {
 		ethernet4		= &xgmac1;
 		gic			= &gic;
 		gpio			= &gpio;
+		hda			= &hda;
 		i2c0			= &i2c0;
 		i2c1			= &i2c1;
 		i2s			= &i2s;
@@ -646,6 +647,14 @@ lsdma: dma@202B0000 {
 		};
 
 		/* AVLSP: HDA (202C0000, 10000, SPI_86_H) */
+		hda: hda@202c0000 {
+			compatible = "be,cw-hda";
+			reg = <0x0 0x202c0000 0x0 0x1000>;
+			interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cmu0_avlsp 15>, <&cmu0_avlsp 16>;
+			clock-names = "hda_sys_clk", "hda_clk48";
+			status = "disabled";
+		};
 
 		/* AVLSP: VDU (202D0000, 10000, SPI_144-145_?) */
 		vdu0: vdu_lvds@202D0000 {
diff --git a/arch/arm64/configs/baikal_defconfig b/arch/arm64/configs/baikal_defconfig
index 1653269e20bf..7820bf199b5d 100644
--- a/arch/arm64/configs/baikal_defconfig
+++ b/arch/arm64/configs/baikal_defconfig
@@ -634,6 +634,7 @@ CONFIG_MEDIA_CAMERA_SUPPORT=y
 CONFIG_MEDIA_CONTROLLER=y
 CONFIG_VIDEO_V4L2_SUBDEV_API=y
 CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_AUDIO=m
 CONFIG_USB_VIDEO_CLASS=m
 CONFIG_USB_M5602=m
 CONFIG_USB_STV06XX=m
@@ -731,23 +732,10 @@ CONFIG_SND_HRTIMER=m
 CONFIG_SND_SEQUENCER=m
 CONFIG_SND_SEQUENCER_OSS=m
 CONFIG_SND_DUMMY=m
-CONFIG_SND_HDA_INTEL=m
 CONFIG_SND_HDA_HWDEP=y
 CONFIG_SND_HDA_INPUT_BEEP=y
-CONFIG_SND_HDA_PATCH_LOADER=y
-CONFIG_SND_HDA_CODEC_REALTEK=m
-CONFIG_SND_HDA_CODEC_ANALOG=m
-CONFIG_SND_HDA_CODEC_SIGMATEL=m
-CONFIG_SND_HDA_CODEC_VIA=m
-CONFIG_SND_HDA_CODEC_HDMI=m
-CONFIG_SND_HDA_CODEC_CIRRUS=m
-CONFIG_SND_HDA_CODEC_CONEXANT=m
-CONFIG_SND_HDA_CODEC_CA0110=m
-CONFIG_SND_HDA_CODEC_CA0132=m
-CONFIG_SND_HDA_CODEC_CA0132_DSP=y
-CONFIG_SND_HDA_CODEC_CMEDIA=m
-CONFIG_SND_HDA_CODEC_SI3054=m
 # CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=y
 # CONFIG_SND_FIREWIRE is not set
 CONFIG_SND_SOC=y
 CONFIG_SND_DESIGNWARE_I2S=y
@@ -902,6 +890,9 @@ CONFIG_TEST_STATIC_KEYS=m
 CONFIG_KGDB=y
 CONFIG_KGDB_KDB=y
 CONFIG_IO_STRICT_DEVMEM=y
+CONFIG_SND_HDA=y
+CONFIG_SND_HDA_BAIKAL_M=y
+CONFIG_SND_HDA_CODEC_REALTEK=y
 CONFIG_ACPI=y
 CONFIG_NET_PKTGEN=y
 CONFIG_DEBUG_FS=y
diff --git a/arch/arm64/configs/edelweiss_e107_mb_a0_defconfig b/arch/arm64/configs/edelweiss_e107_mb_a0_defconfig
index b47b35178c95..82a9f40c7c0c 100644
--- a/arch/arm64/configs/edelweiss_e107_mb_a0_defconfig
+++ b/arch/arm64/configs/edelweiss_e107_mb_a0_defconfig
@@ -166,6 +166,8 @@ CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
 CONFIG_SOUND=y
 CONFIG_SND=y
+CONFIG_SND_HDA_BAIKAL_M=m
+CONFIG_SND_HDA_CODEC_REALTEK=m
 CONFIG_SND_USB_AUDIO=m
 CONFIG_SND_SOC=y
 CONFIG_SND_DESIGNWARE_I2S=y
diff --git a/arch/arm64/configs/edelweiss_tf307_mb_d_defconfig b/arch/arm64/configs/edelweiss_tf307_mb_d_defconfig
index 4295c9acd0cd..5ae3ebe03dfd 100644
--- a/arch/arm64/configs/edelweiss_tf307_mb_d_defconfig
+++ b/arch/arm64/configs/edelweiss_tf307_mb_d_defconfig
@@ -347,6 +347,8 @@ CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
 CONFIG_SOUND=y
 CONFIG_SND=y
+CONFIG_SND_HDA_BAIKAL_M=m
+CONFIG_SND_HDA_CODEC_REALTEK=m
 CONFIG_SND_USB_AUDIO=m
 CONFIG_SND_SOC=y
 CONFIG_SND_DESIGNWARE_I2S=y
diff --git a/arch/arm64/configs/elpitech_et101_mb_a1_a2_defconfig b/arch/arm64/configs/elpitech_et101_mb_a1_a2_defconfig
index 4295c9acd0cd..5ae3ebe03dfd 100644
--- a/arch/arm64/configs/elpitech_et101_mb_a1_a2_defconfig
+++ b/arch/arm64/configs/elpitech_et101_mb_a1_a2_defconfig
@@ -347,6 +347,8 @@ CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
 CONFIG_SOUND=y
 CONFIG_SND=y
+CONFIG_SND_HDA_BAIKAL_M=m
+CONFIG_SND_HDA_CODEC_REALTEK=m
 CONFIG_SND_USB_AUDIO=m
 CONFIG_SND_SOC=y
 CONFIG_SND_DESIGNWARE_I2S=y
diff --git a/arch/arm64/configs/tp_baikal_defconfig b/arch/arm64/configs/tp_baikal_defconfig
index 94af81b6afc6..94f4247c6b69 100644
--- a/arch/arm64/configs/tp_baikal_defconfig
+++ b/arch/arm64/configs/tp_baikal_defconfig
@@ -704,7 +704,7 @@ CONFIG_SND_HRTIMER=m
 CONFIG_SND_SEQUENCER=m
 CONFIG_SND_SEQUENCER_OSS=m
 CONFIG_SND_DUMMY=m
-CONFIG_SND_HDA_INTEL=m
+CONFIG_SND_HDA_BAIKAL_M=m
 CONFIG_SND_HDA_HWDEP=y
 CONFIG_SND_HDA_INPUT_BEEP=y
 CONFIG_SND_HDA_PATCH_LOADER=y
diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 062da7a7a586..8457303be873 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -31,9 +31,11 @@ static void azx_clear_corbrp(struct hdac_bus *bus)
 			break;
 		udelay(1);
 	}
+#ifndef CONFIG_SND_HDA_BAIKAL_M
 	if (timeout <= 0)
 		dev_err(bus->dev, "CORB reset timeout#2, CORBRP = %d\n",
 			snd_hdac_chip_readw(bus, CORBRP));
+#endif
 }
 
 /**
@@ -78,8 +80,15 @@ void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
 	snd_hdac_chip_writew(bus, RIRBWP, AZX_RIRBWP_RST);
 	/* set N=1, get RIRB response interrupt for new entry */
 	snd_hdac_chip_writew(bus, RINTCNT, 1);
+
+#ifdef CONFIG_SND_HDA_BAIKAL_M
+	/* response irq not working in Baikal-M HDA controller */ 
+	snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN);
+#else
 	/* enable rirb dma and response irq */
 	snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
+#endif
+
 	/* Accept unsolicited responses */
 	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);
 	spin_unlock_irq(&bus->reg_lock);
@@ -146,6 +155,11 @@ int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val)
 
 	spin_lock_irq(&bus->reg_lock);
 
+#ifdef CONFIG_SND_HDA_BAIKAL_M
+	/* force first codec address, because wrong codec init */
+	val |= 0x10000000;
+#endif
+
 	bus->last_cmd[azx_command_addr(val)] = val;
 
 	/* add command to corb */
@@ -155,6 +169,7 @@ int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val)
 		spin_unlock_irq(&bus->reg_lock);
 		return -EIO;
 	}
+
 	wp++;
 	wp %= AZX_MAX_CORB_ENTRIES;
 
diff --git a/sound/pci/hda/Kconfig b/sound/pci/hda/Kconfig
index c4360cdbc728..8067310bb976 100644
--- a/sound/pci/hda/Kconfig
+++ b/sound/pci/hda/Kconfig
@@ -42,6 +42,19 @@ config SND_HDA_TEGRA
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-hda-tegra.
 
+config SND_HDA_BAIKAL_M
+	tristate "Baikal-M HD Audio"
+	depends on ARCH_BAIKAL
+	select SND_HDA
+	select SND_HDA_ALIGNED_MMIO
+	help
+	  Say Y here to support the HDA controller present in Baikal-M 
+	  SoC
+
+	  This options enables support for the HD Audio controller
+	  present in Baikal-M SoC, used to communicate audio
+	  to the mezzanine board outputs.
+
 if SND_HDA
 
 config SND_HDA_HWDEP
diff --git a/sound/pci/hda/Makefile b/sound/pci/hda/Makefile
index b57432f00056..065238009cfb 100644
--- a/sound/pci/hda/Makefile
+++ b/sound/pci/hda/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 snd-hda-intel-objs := hda_intel.o
 snd-hda-tegra-objs := hda_tegra.o
+snd-hda-baikal-m-objs := hda_baikal.o
 
 snd-hda-codec-y := hda_bind.o hda_codec.o hda_jack.o hda_auto_parser.o hda_sysfs.o
 snd-hda-codec-y += hda_controller.o
@@ -48,3 +49,4 @@ obj-$(CONFIG_SND_HDA_CODEC_HDMI) += snd-hda-codec-hdmi.o
 # when built in kernel
 obj-$(CONFIG_SND_HDA_INTEL) += snd-hda-intel.o
 obj-$(CONFIG_SND_HDA_TEGRA) += snd-hda-tegra.o
+obj-$(CONFIG_SND_HDA_BAIKAL_M) += snd-hda-baikal-m.o
\ No newline at end of file
diff --git a/sound/pci/hda/hda_baikal.c b/sound/pci/hda/hda_baikal.c
new file mode 100644
index 000000000000..5032d78e4f7f
--- /dev/null
+++ b/sound/pci/hda/hda_baikal.c
@@ -0,0 +1,525 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *
+ * Implementation of primary ALSA driver code base for Baikal-M HDA controller.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/string.h>
+#include <linux/pm_runtime.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+
+#include <sound/hda_codec.h>
+#include "hda_controller.h"
+
+#ifdef CONFIG_PM
+static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;
+module_param(power_save, bint, 0644);
+MODULE_PARM_DESC(power_save,
+		 "Automatic power-saving timeout (in seconds, 0 = disable).");
+#else
+#define power_save	0
+#endif
+
+/* max number of SDs */
+#define NUM_CAPTURE_SD 4
+#define NUM_PLAYBACK_SD 4
+
+struct hda_baikal {
+	struct azx chip;
+	struct device *dev;
+	void __iomem *regs;
+	struct work_struct probe_work;
+	struct work_struct irq_pending_work;
+	unsigned int irq_pending_warned:1;
+};
+
+static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);
+static const struct hda_controller_ops hda_baikal_ops;
+
+/* calculate runtime delay from LPIB */
+static int azx_get_delay_from_lpib(struct azx *chip, struct azx_dev *azx_dev,
+				   unsigned int pos)
+{
+	struct snd_pcm_substream *substream = azx_dev->core.substream;
+	int stream = substream->stream;
+	unsigned int lpib_pos = azx_get_pos_lpib(chip, azx_dev);
+	int delay;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		delay = pos - lpib_pos;
+	else
+		delay = lpib_pos - pos;
+	if (delay < 0) {
+		if (delay >= azx_dev->core.delay_negative_threshold)
+			delay = 0;
+		else
+			delay += azx_dev->core.bufsize;
+	}
+
+	if (delay >= azx_dev->core.period_bytes) {
+		dev_info(chip->card->dev,
+			 "Unstable LPIB (%d >= %d); disabling LPIB delay counting\n",
+			 delay, azx_dev->core.period_bytes);
+		delay = 0;
+		chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
+		chip->get_delay[stream] = NULL;
+	}
+
+	return bytes_to_frames(substream->runtime, delay);
+}
+
+/* called from IRQ */
+static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
+{
+	struct hda_baikal *hda = container_of(chip, struct hda_baikal, chip);
+	int ok;
+
+	ok = azx_position_ok(chip, azx_dev);
+
+	if (ok == 1) {
+		azx_dev->irq_pending = 0;
+		return ok;
+	} else if (ok == 0) {
+		/* bogus IRQ, process it later */
+		azx_dev->irq_pending = 1;
+		schedule_work(&hda->irq_pending_work);
+	}
+	return 0;
+}
+
+/*
+ * Check whether the current DMA position is acceptable for updating
+ * periods.  Returns non-zero if it's OK.
+ *
+ * Many HD-audio controllers appear pretty inaccurate about
+ * the update-IRQ timing.  The IRQ is issued before actually the
+ * data is processed.  So, we need to process it afterwords in a
+ * workqueue.
+ */
+static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
+{
+	struct snd_pcm_substream *substream = azx_dev->core.substream;
+	int stream = substream->stream;
+	u32 wallclk;
+	unsigned int pos;
+
+	wallclk = azx_readl(chip, WALLCLK) - azx_dev->core.start_wallclk;
+	if (wallclk < (azx_dev->core.period_wallclk * 2) / 3)
+		return -1;	/* bogus (too early) interrupt */
+
+	if (chip->get_position[stream])
+		pos = chip->get_position[stream](chip, azx_dev);
+	else { /* use the position buffer as default */
+		pos = azx_get_pos_posbuf(chip, azx_dev);
+		if (!pos || pos == (u32)-1) {
+			dev_info(chip->card->dev,
+				 "Invalid position buffer, using LPIB read method instead.\n");
+			chip->get_position[stream] = azx_get_pos_lpib;
+			if (chip->get_position[0] == azx_get_pos_lpib &&
+			    chip->get_position[1] == azx_get_pos_lpib)
+				azx_bus(chip)->use_posbuf = false;
+			pos = azx_get_pos_lpib(chip, azx_dev);
+			chip->get_delay[stream] = NULL;
+		} else {
+			chip->get_position[stream] = azx_get_pos_posbuf;
+			if (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)
+				chip->get_delay[stream] = azx_get_delay_from_lpib;
+		}
+	}
+
+	if (pos >= azx_dev->core.bufsize)
+		pos = 0;
+
+	if (WARN_ONCE(!azx_dev->core.period_bytes,
+		      "hda-baikal: zero azx_dev->period_bytes"))
+		return -1; /* this shouldn't happen! */
+	if (wallclk < (azx_dev->core.period_wallclk * 5) / 4 &&
+	    pos % azx_dev->core.period_bytes > azx_dev->core.period_bytes / 2)
+		/* NG - it's below the first next period boundary */
+		return chip->bdl_pos_adj ? 0 : -1;
+	azx_dev->core.start_wallclk += wallclk;
+	return 1; /* OK, it's fine */
+}
+
+/*
+ * The work for pending PCM period updates.
+ */
+static void azx_irq_pending_work(struct work_struct *work)
+{
+	struct hda_baikal *hda = container_of(work, struct hda_baikal, irq_pending_work);
+	struct azx *chip = &hda->chip;
+	struct hdac_bus *bus = azx_bus(chip);
+	struct hdac_stream *s;
+	int pending, ok;
+
+	if (!hda->irq_pending_warned) {
+		dev_info(chip->card->dev,
+			 "IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",
+			 chip->card->number);
+		hda->irq_pending_warned = 1;
+	}
+
+	for (;;) {
+		pending = 0;
+		spin_lock_irq(&bus->reg_lock);
+		list_for_each_entry(s, &bus->stream_list, list) {
+			struct azx_dev *azx_dev = stream_to_azx_dev(s);
+			if (!azx_dev->irq_pending ||
+			    !s->substream ||
+			    !s->running)
+				continue;
+			ok = azx_position_ok(chip, azx_dev);
+			if (ok > 0) {
+				azx_dev->irq_pending = 0;
+				spin_unlock(&bus->reg_lock);
+				snd_pcm_period_elapsed(s->substream);
+				spin_lock(&bus->reg_lock);
+			} else if (ok < 0) {
+				pending = 0;	/* too early */
+			} else
+				pending++;
+		}
+		spin_unlock_irq(&bus->reg_lock);
+		if (!pending)
+			return;
+		msleep(1);
+	}
+}
+
+/* clear irq_pending flags and assure no on-going workq */
+static void azx_clear_irq_pending(struct azx *chip)
+{
+	struct hdac_bus *bus = azx_bus(chip);
+	struct hdac_stream *s;
+
+	spin_lock_irq(&bus->reg_lock);
+	list_for_each_entry(s, &bus->stream_list, list) {
+		struct azx_dev *azx_dev = stream_to_azx_dev(s);
+		azx_dev->irq_pending = 0;
+	}
+	spin_unlock_irq(&bus->reg_lock);
+}
+
+static int hda_baikal_dev_disconnect(struct snd_device *device)
+{
+	struct azx *chip = device->device_data;
+
+	chip->bus.shutdown = 1;
+	return 0;
+}
+
+static int hda_baikal_dev_free(struct snd_device *device)
+{
+	struct azx *chip = device->device_data;
+	struct hda_baikal *hda = container_of(chip, struct hda_baikal, chip);
+
+	cancel_work_sync(&hda->probe_work);
+	if (azx_bus(chip)->chip_init) {
+		azx_clear_irq_pending(chip);
+		azx_stop_all_streams(chip);
+		azx_stop_chip(chip);
+	}
+
+	azx_free_stream_pages(chip);
+	azx_free_streams(chip);
+	snd_hdac_bus_exit(azx_bus(chip));
+
+	return 0;
+}
+
+static int hda_baikal_init_chip(struct azx *chip, struct platform_device *pdev)
+{
+	struct hda_baikal *hda = container_of(chip, struct hda_baikal, chip);
+	struct hdac_bus *bus = azx_bus(chip);
+	struct device *dev = hda->dev;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hda->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(hda->regs))
+		return PTR_ERR(hda->regs);
+
+	bus->remap_addr = hda->regs;
+	bus->addr = res->start;
+
+	return 0;
+}
+
+static int hda_baikal_first_init(struct azx *chip, struct platform_device *pdev)
+{
+	struct hdac_bus *bus = azx_bus(chip);
+	struct snd_card *card = chip->card;
+	int err;
+	unsigned short gcap;
+	int irq_id = platform_get_irq(pdev, 0);
+	const char *sname, *drv_name = "baikal-hda";
+	struct device_node *np = pdev->dev.of_node;
+
+	err = hda_baikal_init_chip(chip, pdev);
+	if (err)
+		return err;
+
+	err = devm_request_irq(chip->card->dev, irq_id, azx_interrupt,
+			     IRQF_SHARED, KBUILD_MODNAME, chip);
+	if (err) {
+		dev_err(chip->card->dev,
+			"unable to request IRQ %d, disabling device\n",
+			irq_id);
+		return err;
+	}
+	bus->irq = irq_id;
+
+	synchronize_irq(bus->irq);
+
+	gcap = azx_readw(chip, GCAP);
+	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
+
+	/* force polling mode, because RIRB interrupts don't working */
+	bus->polling_mode = 1;
+
+	/* read number of streams from GCAP register instead of using
+	 * hardcoded value
+	 */
+	chip->capture_streams = (gcap >> 8) & 0x0f;
+	chip->playback_streams = (gcap >> 12) & 0x0f;
+	if (!chip->playback_streams && !chip->capture_streams) {
+		/* gcap didn't give any info, switching to old method */
+		chip->playback_streams = NUM_PLAYBACK_SD;
+		chip->capture_streams = NUM_CAPTURE_SD;
+	}
+	chip->capture_index_offset = 0;
+	chip->playback_index_offset = chip->capture_streams;
+	chip->num_streams = chip->playback_streams + chip->capture_streams;
+
+	/* initialize streams */
+	err = azx_init_streams(chip);
+	if (err < 0) {
+		dev_err(card->dev, "failed to initialize streams: %d\n", err);
+		return err;
+	}
+
+	err = azx_alloc_stream_pages(chip);
+	if (err < 0) {
+		dev_err(card->dev, "failed to allocate stream pages: %d\n",
+			err);
+		return err;
+	}
+
+	/* initialize chip */
+	azx_init_chip(chip, 1);
+
+	/* codec detection */
+	if (!bus->codec_mask) {
+		dev_err(card->dev, "no codecs found!\n");
+		return -ENODEV;
+	}
+
+	/* driver name */
+	strncpy(card->driver, drv_name, sizeof(card->driver));
+	/* shortname for card */
+	sname = of_get_property(np, "baikal,model", NULL);
+	if (!sname)
+		sname = drv_name;
+	if (strlen(sname) > sizeof(card->shortname))
+		dev_info(card->dev, "truncating shortname for card\n");
+	strncpy(card->shortname, sname, sizeof(card->shortname));
+
+	/* longname for card */
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s at 0x%lx irq %i",
+		 card->shortname, bus->addr, bus->irq);
+
+	return 0;
+}
+
+static void hda_baikal_probe_work(struct work_struct *work);
+
+static int hda_baikal_create(struct snd_card *card,
+			    unsigned int driver_caps,
+			    struct hda_baikal *hda)
+{
+	static struct snd_device_ops ops = {
+		.dev_disconnect = hda_baikal_dev_disconnect,
+		.dev_free = hda_baikal_dev_free,
+	};
+	struct azx *chip;
+	int err;
+
+	chip = &hda->chip;
+
+	mutex_init(&chip->open_mutex);
+	chip->card = card;
+	chip->ops = &hda_baikal_ops;
+	chip->driver_caps = driver_caps;
+	chip->driver_type = driver_caps & 0xff;
+	chip->dev_index = 0;
+	INIT_LIST_HEAD(&chip->pcm_list);
+	INIT_WORK(&hda->irq_pending_work, azx_irq_pending_work);
+
+	chip->codec_probe_mask = 3; /* two codecs: first and second bits */
+
+	chip->single_cmd = false;
+	chip->snoop = true;
+
+	chip->get_position[0] = chip->get_position[1] = azx_get_pos_lpib;
+	chip->get_delay[0] = chip->get_delay[1] = azx_get_delay_from_lpib;
+
+	INIT_WORK(&hda->probe_work, hda_baikal_probe_work);
+
+	err = azx_bus_init(chip, NULL);
+	if (err < 0)
+		return err;
+
+	chip->bus.core.needs_damn_long_delay = 1;
+	chip->bus.core.aligned_mmio = 1;
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0) {
+		dev_err(card->dev, "Error creating device\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static int hda_baikal_probe(struct platform_device *pdev)
+{
+	const unsigned int driver_flags = AZX_DCAPS_PM_RUNTIME |
+					  AZX_DCAPS_NO_64BIT |
+					  AZX_DCAPS_4K_BDLE_BOUNDARY |
+					  AZX_DCAPS_COUNT_LPIB_DELAY;
+	struct snd_card *card;
+	struct azx *chip;
+	struct hda_baikal *hda;
+	int err;
+
+	hda = devm_kzalloc(&pdev->dev, sizeof(*hda), GFP_KERNEL);
+	if (!hda)
+		return -ENOMEM;
+	hda->dev = &pdev->dev;
+	chip = &hda->chip;
+
+	err = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			   THIS_MODULE, 0, &card);
+	if (err < 0) {
+		dev_err(&pdev->dev, "Error creating card!\n");
+		return err;
+	}
+
+	err = hda_baikal_create(card, driver_flags, hda);
+	if (err < 0)
+		goto out_free;
+	card->private_data = chip;
+
+	dev_set_drvdata(&pdev->dev, card);
+
+	pm_runtime_enable(hda->dev);
+	if (!azx_has_pm_runtime(chip))
+		pm_runtime_forbid(hda->dev);
+
+	schedule_work(&hda->probe_work);
+
+	return 0;
+
+out_free:
+	snd_card_free(card);
+	return err;
+}
+
+static void hda_baikal_probe_work(struct work_struct *work)
+{
+	struct hda_baikal *hda = container_of(work, struct hda_baikal, probe_work);
+	struct azx *chip = &hda->chip;
+	struct platform_device *pdev = to_platform_device(hda->dev);
+	int err;
+
+	pm_runtime_get_sync(hda->dev);
+	err = hda_baikal_first_init(chip, pdev);
+	if (err < 0)
+		goto out_free;
+
+	/* create codec instances */
+	err = azx_probe_codecs(chip, 1);
+	if (err < 0)
+		goto out_free;
+
+	err = azx_codec_configure(chip);
+	if (err < 0)
+		goto out_free;
+
+	err = snd_card_register(chip->card);
+	if (err < 0)
+		goto out_free;
+
+	chip->running = 1;
+
+	snd_hda_set_power_save(&chip->bus, power_save * 1000);
+
+ out_free:
+	pm_runtime_put(hda->dev);
+	return; /* no error return from async probe */
+}
+
+static int hda_baikal_remove(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = snd_card_free(dev_get_drvdata(&pdev->dev));
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static void hda_baikal_shutdown(struct platform_device *pdev)
+{
+	struct snd_card *card = dev_get_drvdata(&pdev->dev);
+	struct azx *chip;
+
+	if (!card)
+		return;
+	chip = card->private_data;
+	if (chip && chip->running)
+		azx_stop_chip(chip);
+}
+
+static const struct hda_controller_ops hda_baikal_ops = {
+	.position_check = azx_position_check,
+};
+
+static const struct of_device_id hda_baikal_match[] = {
+	{ .compatible = "be,cw-hda" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, hda_baikal_match);
+
+static struct platform_driver baikal_platform_hda = {
+	.driver = {
+		.name = "baikal-hda",
+		.of_match_table = hda_baikal_match,
+	},
+	.probe = hda_baikal_probe,
+	.remove = hda_baikal_remove,
+	.shutdown = hda_baikal_shutdown,
+};
+module_platform_driver(baikal_platform_hda);
+
+MODULE_DESCRIPTION("Baikal HDA bus driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/pci/hda/hda_controller.c b/sound/pci/hda/hda_controller.c
index ca2f2ecd1488..77ed014c5544 100644
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@ -1208,32 +1208,59 @@ int azx_probe_codecs(struct azx *chip, unsigned int max_slots)
 	struct hdac_bus *bus = azx_bus(chip);
 	int c, codecs, err;
 
+#ifdef CONFIG_SND_HDA_BAIKAL_M
+	int probe_retry;
+#endif
+
 	codecs = 0;
 	if (!max_slots)
 		max_slots = AZX_DEFAULT_CODECS;
 
+#ifdef CONFIG_SND_HDA_BAIKAL_M
 	/* First try to probe all given codec slots */
 	for (c = 0; c < max_slots; c++) {
 		if ((bus->codec_mask & (1 << c)) & chip->codec_probe_mask) {
-			if (probe_codec(chip, c) < 0) {
-				/* Some BIOSen give you wrong codec addresses
-				 * that don't exist
-				 */
-				dev_warn(chip->card->dev,
-					 "Codec #%d probe error; disabling it...\n", c);
+			for (probe_retry = 0; probe_retry < 100; probe_retry++) {
+				if (probe_codec(chip, c) < 0) {
+					azx_stop_chip(chip);
+					azx_init_chip(chip, true);
+					continue;
+				}
+				else {
+					dev_warn(chip->card->dev,
+						"Codec #%d probe success; retry count = %d\n", c, probe_retry);
+					break;
+				}
 				bus->codec_mask &= ~(1 << c);
-				/* More badly, accessing to a non-existing
-				 * codec often screws up the controller chip,
-				 * and disturbs the further communications.
-				 * Thus if an error occurs during probing,
-				 * better to reset the controller chip to
-				 * get back to the sanity state.
-				 */
-				azx_stop_chip(chip);
-				azx_init_chip(chip, true);
+				dev_warn(chip->card->dev,
+					"Codec #%d probe error; disabling it...\n", c);
+			}
+		}
+	}
+#else
+	/* First try to probe all given codec slots */
+	for (c = 0; c < max_slots; c++) {
+		if ((bus->codec_mask & (1 << c)) & chip->codec_probe_mask) {
+			if (probe_codec(chip, c) < 0) {
+					/* Some BIOSen give you wrong codec addresses
+					 * that don't exist
+					 */
+					dev_warn(chip->card->dev,
+						"Codec #%d probe error; disabling it...\n", c);
+					bus->codec_mask &= ~(1 << c);
+					/* More badly, accessing to a non-existing
+					 * codec often screws up the controller chip,
+					 * and disturbs the further communications.
+					 * Thus if an error occurs during probing,
+					 * better to reset the controller chip to
+					 * get back to the sanity state.
+					 */
+					azx_stop_chip(chip);
+					azx_init_chip(chip, true);
 			}
 		}
 	}
+#endif
 
 	/* Then create codec instances */
 	for (c = 0; c < max_slots; c++) {
-- 
2.33.0

