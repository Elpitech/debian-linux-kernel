From 050fa4087eaa807cf2a6378abab5b2c4733dd59b Mon Sep 17 00:00:00 2001
From: Roman Stavtsev <roman.stavtsev@baikalelectronics.ru>
Date: Sat, 17 Apr 2021 16:50:35 +0300
Subject: [PATCH 020/106] Baikal-M: i2s driver

---
 sound/soc/dwc/Makefile  |   1 +
 sound/soc/dwc/be_snd.c  | 129 ++++++++++++++++++++++++++++++++++++++++
 sound/soc/dwc/dwc-i2s.c |  67 ++++++++++++++++++---
 3 files changed, 188 insertions(+), 9 deletions(-)
 create mode 100644 sound/soc/dwc/be_snd.c

diff --git a/sound/soc/dwc/Makefile b/sound/soc/dwc/Makefile
index 91e1aaab9966..5d88dae304f1 100644
--- a/sound/soc/dwc/Makefile
+++ b/sound/soc/dwc/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # SYNOPSYS Platform Support
 obj-$(CONFIG_SND_DESIGNWARE_I2S) += designware_i2s.o
+obj-$(CONFIG_ARCH_BAIKAL) += be_snd.o
 
 designware_i2s-y := dwc-i2s.o
 designware_i2s-$(CONFIG_SND_DESIGNWARE_PCM) += dwc-pcm.o
diff --git a/sound/soc/dwc/be_snd.c b/sound/soc/dwc/be_snd.c
new file mode 100644
index 000000000000..b6048758b820
--- /dev/null
+++ b/sound/soc/dwc/be_snd.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) Baikal Electronics 2019
+ *
+ * Author: Ekaterina Skachko (Ekaterina.Skachko@baikalelectronics.ru)
+ *         for Baikal Electronics.
+ *
+ * License terms:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+#include <sound/soc.h>
+#include <sound/initval.h>
+
+#include "local.h"
+
+static struct snd_soc_dai_link snd_be_dai = {
+	.name = "dw_i2s",
+	.stream_name = "dw_i2s",
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM,
+};
+
+static struct snd_soc_card snd_be_card = {
+	.name		= "snd_be_card",
+	.owner		= THIS_MODULE,
+	.dai_link	= &snd_be_dai,
+	.num_links	= 1,
+};
+
+static int snd_soc_be_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *codec_np, *be_np;
+	struct snd_soc_dai_link_component *comp;
+
+	snd_be_card.dev = &pdev->dev;
+
+	be_np = of_parse_phandle(np, "baikal,cpu-dai", 0);
+	codec_np  = of_parse_phandle(np, "baikal,audio-codec", 0);
+
+	if (!(be_np && codec_np)) {
+		dev_err(&pdev->dev, "Phandle missing or invalid\n");
+		return -EINVAL;
+	}
+	/* for cpus/codecs/platforms */
+	comp = devm_kzalloc(&pdev->dev, 3 * sizeof(*comp), GFP_KERNEL);
+	if (!comp)
+		return -ENOMEM;
+
+	snd_be_dai.cpus = &comp[0];
+	snd_be_dai.num_cpus = 1;
+	snd_be_dai.codecs = &comp[1];
+	snd_be_dai.num_codecs = 1;
+	snd_be_dai.platforms = &comp[2];
+	snd_be_dai.num_platforms = 1;
+
+	snd_be_dai.codecs->of_node = codec_np;
+	snd_be_dai.cpus->of_node = be_np;
+	snd_be_dai.platforms->of_node = be_np;
+
+	snd_soc_of_parse_card_name(&snd_be_card, "baikal,card-name");
+
+
+	dev_dbg(&pdev->dev, "%s: Card %s: Set platform drvdata.\n",
+		__func__, snd_be_card.name);
+	platform_set_drvdata(pdev, &snd_be_card);
+
+	snd_soc_card_set_drvdata(&snd_be_card, NULL);
+
+	dev_dbg(&pdev->dev, "%s: Card %s: num_links = %d\n",
+		__func__, snd_be_card.name, snd_be_card.num_links);
+	dev_dbg(&pdev->dev, "%s: Card %s: DAI-link 0: name = %s\n",
+		__func__, snd_be_card.name, snd_be_card.dai_link[0].name);
+	dev_dbg(&pdev->dev, "%s: Card %s: DAI-link 0: stream_name = %s\n",
+		__func__, snd_be_card.name,
+		snd_be_card.dai_link[0].stream_name);
+
+	ret = snd_soc_register_card(&snd_be_card);
+	if (ret)
+		dev_err(&pdev->dev,
+			"Error: snd_soc_register_card failed (%d)!\n", ret);
+
+
+	return ret;
+}
+
+static int snd_soc_be_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *snd_be_card = platform_get_drvdata(pdev);
+
+	pr_debug("%s: Enter.\n", __func__);
+
+	snd_soc_unregister_card(snd_be_card);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id snd_soc_be_of_match[] = {
+	{ .compatible = "baikal,snd_soc_be",	 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, snd_soc_be_of_match);
+#endif
+
+
+static struct platform_driver snd_soc_be_driver = {
+	.probe		= snd_soc_be_probe,
+	.remove		= snd_soc_be_remove,
+	.driver		= {
+		.name	= "snd_soc_be",
+		.of_match_table = of_match_ptr(snd_soc_be_of_match),
+	},
+};
+
+module_platform_driver(snd_soc_be_driver);
+
+MODULE_AUTHOR("Ekaterina Skachko <Ekaterina.Skachko@baikalelectronics.ru>");
+MODULE_DESCRIPTION("Baikal-M SoC Sound Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/dwc/dwc-i2s.c b/sound/soc/dwc/dwc-i2s.c
index fd4160289fac..783dd534c967 100644
--- a/sound/soc/dwc/dwc-i2s.c
+++ b/sound/soc/dwc/dwc-i2s.c
@@ -26,6 +26,9 @@
 #include <sound/dmaengine_pcm.h>
 #include "local.h"
 
+#define MASTER_CLK 12000000
+static uint32_t freq;
+
 static inline void i2s_write_reg(void __iomem *io_base, int reg, u32 val)
 {
 	writel(val, io_base + reg);
@@ -203,6 +206,9 @@ static int dw_i2s_startup(struct snd_pcm_substream *substream,
 		dma_data = &dev->capture_dma_data;
 
 	snd_soc_dai_set_dma_data(cpu_dai, substream, (void *)dma_data);
+	snd_soc_dai_set_sysclk(cpu_dai, 0,
+                             freq, SND_SOC_CLOCK_IN);
+
 
 	return 0;
 }
@@ -617,14 +623,43 @@ static int dw_configure_dai_by_dt(struct dw_i2s_dev *dev,
 
 }
 
+static int dw_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+        struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+        struct snd_dmaengine_dai_dma_data *playback_dma_data;
+        struct snd_dmaengine_dai_dma_data *capture_dma_data;
+
+        playback_dma_data = devm_kzalloc(dai->dev,
+                                         sizeof(*playback_dma_data),
+                                         GFP_KERNEL);
+        if (!playback_dma_data)
+                return -ENOMEM;
+
+        capture_dma_data = devm_kzalloc(dai->dev,
+                                        sizeof(*capture_dma_data),
+                                        GFP_KERNEL);
+        if (!capture_dma_data)
+                return -ENOMEM;
+
+        playback_dma_data->addr = dev->play_dma_data.pd.addr;
+        capture_dma_data->addr = dev->capture_dma_data.pd.addr;
+
+        playback_dma_data->maxburst = dev->play_dma_data.pd.max_burst;
+        capture_dma_data->maxburst = dev->capture_dma_data.pd.max_burst;
+
+        return 0;
+}
+
 static int dw_i2s_probe(struct platform_device *pdev)
 {
 	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
 	struct dw_i2s_dev *dev;
 	struct resource *res;
-	int ret, irq;
+	int ret, irq, irq_num;
 	struct snd_soc_dai_driver *dw_i2s_dai;
 	const char *clk_id;
+	struct device_node *np = pdev->dev.of_node;
+	uint32_t val;
 
 	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
 	if (!dev)
@@ -635,6 +670,7 @@ static int dw_i2s_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	dw_i2s_dai->ops = &dw_i2s_dai_ops;
+	dw_i2s_dai->probe = &dw_i2s_dai_probe;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	dev->i2s_base = devm_ioremap_resource(&pdev->dev, res);
@@ -642,16 +678,23 @@ static int dw_i2s_probe(struct platform_device *pdev)
 		return PTR_ERR(dev->i2s_base);
 
 	dev->dev = &pdev->dev;
+	irq_num = platform_irq_count(pdev);
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq >= 0) {
-		ret = devm_request_irq(&pdev->dev, irq, i2s_irq_handler, 0,
-				pdev->name, dev);
-		if (ret < 0) {
-			dev_err(&pdev->dev, "failed to request irq\n");
-			return ret;
+	if (!irq_num)
+		dev_err(&pdev->dev, "No irq found on device\n");
+
+	do {
+		irq = platform_get_irq(pdev, irq_num);
+		if (irq >= 0) {
+			printk(KERN_INFO "%s Registered IRQ number %d %d\n",__func__, irq, irq_num);
+			ret = devm_request_irq(&pdev->dev, irq, i2s_irq_handler, 0,
+														 pdev->name, dev);
+			if (ret < 0) {
+				dev_err(&pdev->dev, "failed to request irq\n");
+				return ret;
+			}
 		}
-	}
+	} while(irq_num--);
 
 	dev->i2s_reg_comp1 = I2S_COMP_PARAM_1;
 	dev->i2s_reg_comp2 = I2S_COMP_PARAM_2;
@@ -715,8 +758,14 @@ static int dw_i2s_probe(struct platform_device *pdev)
 	}
 
 	pm_runtime_enable(&pdev->dev);
+        if (!of_property_read_u32(np, "system-clock-frequency", &val))
+                freq = val;
+        else
+                freq = MASTER_CLK;
+
 	return 0;
 
+
 err_clk_disable:
 	if (dev->capability & DW_I2S_MASTER)
 		clk_disable_unprepare(dev->clk);
-- 
2.33.0

