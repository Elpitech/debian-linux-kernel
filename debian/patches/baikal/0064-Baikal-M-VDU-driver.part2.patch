From 759922c12d86fb35590a64de23185de1075fae67 Mon Sep 17 00:00:00 2001
From: Roman Stavtsev <roman.stavtsev@baikalelectronics.ru>
Date: Sat, 17 Apr 2021 18:33:27 +0300
Subject: [PATCH 064/106] Baikal-M: VDU driver.part2

---
 drivers/gpu/drm/baikal/Kconfig                |  13 +
 drivers/gpu/drm/baikal/Makefile               |  10 +
 drivers/gpu/drm/baikal/baikal-hdmi.c          | 117 ++++++
 drivers/gpu/drm/baikal/baikal_vdu_connector.c | 171 ++++++++
 drivers/gpu/drm/baikal/baikal_vdu_crtc.c      | 365 ++++++++++++++++
 drivers/gpu/drm/baikal/baikal_vdu_debugfs.c   | 130 ++++++
 drivers/gpu/drm/baikal/baikal_vdu_drm.h       |  67 +++
 drivers/gpu/drm/baikal/baikal_vdu_drv.c       | 394 ++++++++++++++++++
 drivers/gpu/drm/baikal/baikal_vdu_plane.c     | 193 +++++++++
 drivers/gpu/drm/baikal/baikal_vdu_regs.h      | 139 ++++++
 10 files changed, 1599 insertions(+)
 create mode 100644 drivers/gpu/drm/baikal/Kconfig
 create mode 100644 drivers/gpu/drm/baikal/Makefile
 create mode 100644 drivers/gpu/drm/baikal/baikal-hdmi.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_connector.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_crtc.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_debugfs.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_drm.h
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_drv.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_plane.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_regs.h

diff --git a/drivers/gpu/drm/baikal/Kconfig b/drivers/gpu/drm/baikal/Kconfig
new file mode 100644
index 000000000000..a1bcdbe57868
--- /dev/null
+++ b/drivers/gpu/drm/baikal/Kconfig
@@ -0,0 +1,13 @@
+config DRM_BAIKAL_VDU
+	tristate "DRM Support for Baikal-M VDU"
+	depends on DRM
+	depends on ARM || ARM64 || COMPILE_TEST
+	depends on COMMON_CLK
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_GEM_CMA_HELPER
+	select DRM_PANEL
+	select VT_HW_CONSOLE_BINDING if FRAMEBUFFER_CONSOLE
+	help
+	  Choose this option for DRM support for the Baikal-M Video Display Unit (VDU).
+	  If M is selected the module will be called baikal_vdu_drm.
diff --git a/drivers/gpu/drm/baikal/Makefile b/drivers/gpu/drm/baikal/Makefile
new file mode 100644
index 000000000000..eb029494e823
--- /dev/null
+++ b/drivers/gpu/drm/baikal/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+baikal_vdu_drm-y +=	baikal_vdu_connector.o \
+		baikal_vdu_crtc.o \
+		baikal_vdu_drv.o \
+		baikal_vdu_plane.o
+
+baikal_vdu_drm-$(CONFIG_DEBUG_FS) += baikal_vdu_debugfs.o
+
+obj-$(CONFIG_DRM_BAIKAL_VDU) += baikal_vdu_drm.o
+obj-$(CONFIG_DRM_BAIKAL_HDMI) += baikal-hdmi.o
diff --git a/drivers/gpu/drm/baikal/baikal-hdmi.c b/drivers/gpu/drm/baikal/baikal-hdmi.c
new file mode 100644
index 000000000000..cf07176f83ea
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal-hdmi.c
@@ -0,0 +1,117 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Baikal Electronics BE-M1000 DesignWare HDMI 2.0 Tx PHY support driver
+ *
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (C) 2016 Renesas Electronics Corporation
+ *
+ * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ */
+
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <drm/drm_modes.h>
+
+#include <drm/bridge/dw_hdmi.h>
+
+int fixed_clock = 0;
+int max_clock = 0;
+
+static const struct dw_hdmi_mpll_config baikal_hdmi_mpll_cfg[] = {
+	/* pixelclk      opmode  gmp         */
+	{  44900000, { { 0x00b3, 0x0000 }, }, },
+	{  90000000, { { 0x0072, 0x0001 }, }, },
+	{ 182750000, { { 0x0051, 0x0002 }, }, },
+	{ 340000000, { { 0x0040, 0x0003 }, }, },
+	{ 594000000, { { 0x1a40, 0x0003 }, }, },
+	{ ~0UL,      { { 0x0000, 0x0000 }, }, }
+};
+
+static const struct dw_hdmi_curr_ctrl baikal_hdmi_cur_ctr[] = {
+	/* pixelclk    current   */
+	{  44900000, { 0x0000, }, },
+	{  90000000, { 0x0008, }, },
+	{ 182750000, { 0x001b, }, },
+	{ 340000000, { 0x0036, }, },
+	{ 594000000, { 0x003f, }, },
+	{ ~0UL,      { 0x0000, }, }
+};
+
+static const struct dw_hdmi_phy_config baikal_hdmi_phy_cfg[] = {
+	/* pixelclk  symbol  term    vlev */
+	{ 148250000, 0x8009, 0x0004, 0x0232},
+	{ 218250000, 0x8009, 0x0004, 0x0230},
+	{ 288000000, 0x8009, 0x0004, 0x0273},
+	{ 340000000, 0x8029, 0x0004, 0x0273},
+	{ 594000000, 0x8039, 0x0004, 0x014a},
+	{ ~0UL,      0x0000, 0x0000, 0x0000}
+};
+
+static enum drm_mode_status baikal_hdmi_mode_valid(struct drm_connector *con,
+                          const struct drm_display_mode *mode)
+{
+	if (mode->clock < 13500)
+		return MODE_CLOCK_LOW;
+	if (mode->clock >= 600000)
+		return MODE_CLOCK_HIGH;
+	if (fixed_clock && mode->clock != fixed_clock)
+		return MODE_BAD;
+	if (max_clock && mode->clock > max_clock)
+		return MODE_BAD;
+
+	return MODE_OK;
+}
+
+static struct dw_hdmi_plat_data baikal_dw_hdmi_plat_data = {
+	.mpll_cfg   = baikal_hdmi_mpll_cfg,
+	.cur_ctr    = baikal_hdmi_cur_ctr,
+	.phy_config = baikal_hdmi_phy_cfg,
+	.mode_valid = baikal_hdmi_mode_valid,
+};
+
+static int baikal_dw_hdmi_probe(struct platform_device *pdev)
+{
+	struct dw_hdmi *hdmi;
+	hdmi = dw_hdmi_probe(pdev, &baikal_dw_hdmi_plat_data);
+	if (IS_ERR(hdmi)) {
+		return PTR_ERR(hdmi);
+	} else {
+		return 0;
+	}
+}
+
+static int baikal_dw_hdmi_remove(struct platform_device *pdev)
+{
+	struct dw_hdmi *hdmi = platform_get_drvdata(pdev);
+	dw_hdmi_remove(hdmi);
+	return 0;
+}
+
+static const struct of_device_id baikal_dw_hdmi_of_table[] = {
+	{ .compatible = "baikal,hdmi" },
+	{ /* Sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, baikal_dw_hdmi_of_table);
+
+static struct platform_driver baikal_dw_hdmi_platform_driver = {
+	.probe		= baikal_dw_hdmi_probe,
+	.remove		= baikal_dw_hdmi_remove,
+	.driver		= {
+		.name	= "baikal-dw-hdmi",
+		.of_match_table = baikal_dw_hdmi_of_table,
+	},
+};
+
+module_param(fixed_clock, int, 0644);
+module_param(max_clock, int, 0644);
+
+module_platform_driver(baikal_dw_hdmi_platform_driver);
+
+MODULE_AUTHOR("Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>");
+MODULE_DESCRIPTION("Baikal BE-M1000 SoC DesignWare HDMI 2.0 Tx + Gen2 PHY Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_connector.c b/drivers/gpu/drm/baikal/baikal_vdu_connector.c
new file mode 100644
index 000000000000..d165c62ef584
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_connector.c
@@ -0,0 +1,171 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+/**
+ * baikal_vdu_connector.c
+ * Implementation of the connector functions for Baikal Electronics
+ * BE-M1000 SoC's VDU
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+#include "baikal_vdu_drm.h"
+
+static void baikal_vdu_connector_destroy(struct drm_connector *connector)
+{
+	struct baikal_vdu_private *priv =
+		to_baikal_vdu_private(connector);
+
+	if (priv->panel)
+		drm_panel_detach(priv->panel);
+
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+static enum drm_connector_status baikal_vdu_connector_detect(
+		struct drm_connector *connector, bool force)
+{
+	struct baikal_vdu_private *priv =
+		to_baikal_vdu_private(connector);
+
+	return (priv->panel ?
+		connector_status_connected :
+		connector_status_disconnected);
+}
+
+static int baikal_vdu_connector_helper_get_modes(
+		struct drm_connector *connector)
+{
+	struct baikal_vdu_private *priv =
+		to_baikal_vdu_private(connector);
+
+	if (!priv->panel)
+		return 0;
+
+	return drm_panel_get_modes(priv->panel);
+}
+
+int baikal_vdu_lvds_set_property(struct drm_connector *connector,
+				       struct drm_property *property,
+				       uint64_t value)
+{
+	struct drm_encoder *encoder = connector->encoder;
+
+	if (!encoder)
+		return -1;
+
+	if (!strcmp(property->name, "scaling mode")) {
+		uint64_t curval;
+		switch (value) {
+		case DRM_MODE_SCALE_FULLSCREEN:
+			break;
+		case DRM_MODE_SCALE_NO_SCALE:
+			break;
+		case DRM_MODE_SCALE_ASPECT:
+			break;
+		default:
+			goto set_prop_error;
+		}
+
+		if (drm_object_property_get_value(&connector->base,
+						     property,
+						     &curval))
+			goto set_prop_error;
+
+		if (curval == value)
+			goto set_prop_done;
+
+		if (drm_object_property_set_value(&connector->base,
+							property,
+							value))
+			goto set_prop_error;
+
+	} else if (!strcmp(property->name, "backlight")) {
+		if (drm_object_property_set_value(&connector->base,
+							property,
+							value))
+			goto set_prop_error;
+		else {
+			// TBD set backlight
+		}
+	} else if (!strcmp(property->name, "DPMS")) {
+		const struct drm_encoder_helper_funcs *hfuncs
+						= encoder->helper_private;
+		hfuncs->dpms(encoder, value);
+	}
+
+set_prop_done:
+	return 0;
+set_prop_error:
+	return -1;
+}
+
+static void baikal_vdu_lvds_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	// TBD
+}
+
+const struct drm_connector_funcs connector_funcs = {
+	//.dpms = drm_atomic_helper_connector_dpms, // TODO sort this out
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = baikal_vdu_connector_detect,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+	.set_property = baikal_vdu_lvds_set_property,
+	.destroy = baikal_vdu_connector_destroy,
+};
+
+const struct drm_connector_helper_funcs connector_helper_funcs = {
+	.get_modes = baikal_vdu_connector_helper_get_modes,
+};
+
+static const struct drm_encoder_funcs encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static const struct drm_encoder_helper_funcs baikal_vdu_lvds_helper_funcs = {
+	.dpms = baikal_vdu_lvds_encoder_dpms,
+	//.prepare = TBD,
+	//.mode_set = TBD,
+	//.commit = TBD,
+};
+
+int baikal_vdu_lvds_connector_create(struct drm_device *dev)
+{
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_connector *connector = &priv->connector;
+	struct drm_encoder *encoder = &priv->encoder;
+
+	drm_connector_init(dev, connector, &connector_funcs,
+			DRM_MODE_CONNECTOR_LVDS);
+	drm_encoder_init(dev, encoder, &encoder_funcs,
+			DRM_MODE_ENCODER_LVDS, NULL);
+	encoder->crtc = &priv->crtc;
+	encoder->possible_crtcs = BIT(drm_crtc_index(encoder->crtc));
+
+	drm_connector_attach_encoder(connector, encoder);
+
+	drm_encoder_helper_add(encoder, &baikal_vdu_lvds_helper_funcs);
+	drm_connector_helper_add(connector, &connector_helper_funcs);
+
+	drm_connector_register(connector);
+
+	drm_panel_attach(priv->panel, connector);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_crtc.c b/drivers/gpu/drm/baikal/baikal_vdu_crtc.c
new file mode 100644
index 000000000000..d97e6c7d944a
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_crtc.c
@@ -0,0 +1,365 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms of
+ * such GNU licence.
+ *
+ */
+
+/**
+ * baikal_vdu_crtc.c
+ * Implementation of the CRTC functions for Baikal Electronics BE-M1000 VDU driver
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/version.h>
+#include <linux/shmem_fs.h>
+#include <linux/dma-buf.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_vblank.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+struct baikal_vdu_crtc_mode_fixup {
+	int vdisplay;
+	int vfp_add;
+};
+
+static const struct baikal_vdu_crtc_mode_fixup mode_fixups[] = {
+	{ 480, 38 },
+	{ 600, 8 },
+	{ 720, 43 },
+	{ 768, 43 },
+	{ 800, 71 },
+	{ 864, 71 },
+	{ 900, 71 },
+	{ 960, 71 },
+	{ 1024, 25 },
+	{ 1050, 25 },
+	{ 1080, 8 },
+	{ 1200, 32 },
+	{ 1440, 27 },
+	{ ~0U },
+};
+
+irqreturn_t baikal_vdu_irq(int irq, void *data)
+{
+	struct drm_device *drm = data;
+	struct baikal_vdu_private *priv = drm->dev_private;
+	irqreturn_t status = IRQ_NONE;
+	u32 raw_stat;
+	u32 irq_stat;
+
+	irq_stat = readl(priv->regs + IVR);
+	raw_stat = readl(priv->regs + ISR);
+
+
+	if (irq_stat & INTR_VCT) {
+		priv->counters[10]++;
+		drm_crtc_handle_vblank(&priv->crtc);
+		status = IRQ_HANDLED;
+	}
+
+	if (irq_stat & INTR_FER) {
+		priv->counters[11]++;
+		priv->counters[12] = readl(priv->regs + DBAR);
+		priv->counters[13] = readl(priv->regs + DCAR);
+		priv->counters[14] = readl(priv->regs + MRR);
+		status = IRQ_HANDLED;
+	}
+
+	priv->counters[3] |= raw_stat;
+
+	/* Clear all interrupts */
+	writel(irq_stat, priv->regs + ISR);
+
+	return status;
+}
+
+bool baikal_vdu_crtc_mode_fixup(struct drm_crtc *crtc,
+					const struct drm_display_mode *mode,
+					struct drm_display_mode *adjusted_mode)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	memcpy(adjusted_mode, mode, sizeof(*mode));
+
+	if (!priv->mode_fixup)
+		return true;
+
+	if (priv->mode_fixup == -1) {
+		const struct baikal_vdu_crtc_mode_fixup *fixups = mode_fixups;
+		for (; fixups && fixups->vdisplay != ~0U; ++fixups) {
+			if (mode->vdisplay <= fixups->vdisplay)
+				break;
+		}
+		if (fixups->vdisplay == ~0U)
+			return true;
+		else
+			priv->mode_fixup = fixups->vfp_add;
+	}
+
+	adjusted_mode->vtotal += priv->mode_fixup;
+	adjusted_mode->vsync_start += priv->mode_fixup;
+	adjusted_mode->vsync_end += priv->mode_fixup;
+	adjusted_mode->clock = mode->clock * adjusted_mode->vtotal / mode->vtotal;
+
+	return true;
+}
+
+static void baikal_vdu_crtc_helper_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct drm_device *dev = crtc->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	const struct drm_display_mode *orig_mode = &crtc->state->mode;
+	const struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	unsigned long rate;
+	unsigned int ppl, hsw, hfp, hbp;
+	unsigned int lpp, vsw, vfp, vbp;
+	unsigned int reg;
+	int ret = 0;
+
+	drm_mode_debug_printmodeline(orig_mode);
+	drm_mode_debug_printmodeline(mode);
+
+	rate = mode->clock * 1000;
+
+	if (rate != clk_get_rate(priv->clk))
+	{
+		DRM_DEV_DEBUG_DRIVER(dev->dev, "Requested pixel clock is %lu Hz\n", rate);
+
+		/* hold clock domain reset; disable clocking */
+		writel(0, priv->regs + PCTR);
+
+		if (__clk_is_enabled(priv->clk))
+			clk_disable_unprepare(priv->clk);
+		ret = clk_set_rate(priv->clk, rate);
+
+		if (ret >= 0) {
+			clk_prepare_enable(priv->clk);
+			if (!__clk_is_enabled(priv->clk))
+				ret = -1;
+		}
+
+		/* release clock domain reset; enable clocking */
+		reg = readl(priv->regs + PCTR);
+		reg |= PCTR_PCR + PCTR_PCI;
+		writel(reg, priv->regs + PCTR);
+	}
+
+	if (ret < 0)
+		DRM_ERROR("Cannot set desired pixel clock (%lu Hz)\n", rate);
+
+	ppl = mode->hdisplay / 16;
+	if (priv->panel) {
+		hsw = mode->hsync_end - mode->hsync_start;
+		hfp = mode->hsync_start - mode->hdisplay - 1;
+	} else {
+		hsw = mode->hsync_end - mode->hsync_start - 1;
+		hfp = mode->hsync_start - mode->hdisplay;
+	}
+	hbp = mode->htotal - mode->hsync_end;
+
+	lpp = mode->vdisplay;
+	vsw = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+
+	writel((HTR_HFP(hfp) & HTR_HFP_MASK) |
+			(HTR_PPL(ppl) & HTR_PPL_MASK) |
+			(HTR_HBP(hbp) & HTR_HBP_MASK) |
+			(HTR_HSW(hsw) & HTR_HSW_MASK),
+			priv->regs + HTR);
+
+	if (mode->hdisplay > 4080 || ppl * 16 != mode->hdisplay)
+		writel((HPPLOR_HPPLO(mode->hdisplay) & HPPLOR_HPPLO_MASK) | HPPLOR_HPOE,
+				priv->regs + HPPLOR);
+
+	writel((VTR1_VSW(vsw) & VTR1_VSW_MASK) |
+			(VTR1_VFP(vfp) & VTR1_VFP_MASK) |
+			(VTR1_VBP(vbp) & VTR1_VBP_MASK),
+			priv->regs + VTR1);
+
+	writel(lpp & VTR2_LPP_MASK, priv->regs + VTR2);
+
+	writel((HVTER_VSWE(vsw >> VTR1_VSW_LSB_WIDTH) & HVTER_VSWE_MASK) |
+			(HVTER_HSWE(hsw >> HTR_HSW_LSB_WIDTH) & HVTER_HSWE_MASK) |
+			(HVTER_VBPE(vbp >> VTR1_VBP_LSB_WIDTH) & HVTER_VBPE_MASK) |
+			(HVTER_VFPE(vfp >> VTR1_VFP_LSB_WIDTH) & HVTER_VFPE_MASK) |
+			(HVTER_HBPE(hbp >> HTR_HBP_LSB_WIDTH) & HVTER_HBPE_MASK) |
+			(HVTER_HFPE(hfp >> HTR_HFP_LSB_WIDTH) & HVTER_HFPE_MASK),
+			priv->regs + HVTER);
+
+	/* Set polarities */
+	reg = readl(priv->regs + CR1);
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		reg |= CR1_HSP;
+	else
+		reg &= ~CR1_HSP;
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		reg |= CR1_VSP;
+	else
+		reg &= ~CR1_VSP;
+	reg |= CR1_DEP; // set DE to active high;
+	writel(reg, priv->regs + CR1);
+
+	crtc->hwmode = crtc->state->adjusted_mode;
+}
+
+static void baikal_vdu_crtc_helper_enable(struct drm_crtc *crtc,
+					  struct drm_crtc_state *old_state)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+	struct drm_panel *panel = priv->panel;
+	struct device_node *panel_node;
+	const char *data_mapping;
+	u32 cntl, gpio;
+
+	DRM_DEV_DEBUG_DRIVER(crtc->dev->dev, "enabling pixel clock\n");
+	clk_prepare_enable(priv->clk);
+
+	drm_panel_prepare(panel);
+
+	writel(ISCR_VSC_VFP, priv->regs + ISCR);
+
+	/* Set 16-word input FIFO watermark */
+	/* Enable and Power Up */
+	cntl = readl(priv->regs + CR1);
+	cntl &= ~CR1_FDW_MASK;
+	cntl |= CR1_LCE + CR1_FDW_16_WORDS;
+
+	if (priv->type == VDU_TYPE_LVDS) {
+		panel_node = panel->dev->of_node;
+		if (of_property_read_string(panel_node, "data-mapping", &data_mapping)) {
+			cntl |= CR1_OPS_LCD18;
+		} else if (strncmp(data_mapping, "vesa-24", 7))
+			cntl |= CR1_OPS_LCD24;
+		else if (strncmp(data_mapping, "jeida-18", 8))
+			cntl |= CR1_OPS_LCD18;
+		else {
+			dev_warn(crtc->dev->dev, "%s data mapping is not supported, vesa-24 is set\n", data_mapping);
+			cntl |= CR1_OPS_LCD24;
+		}
+		gpio = GPIOR_UHD_ENB;
+		if (priv->ep_count == 4)
+			gpio |= GPIOR_UHD_QUAD_PORT;
+		else if (priv->ep_count == 2)
+			gpio |= GPIOR_UHD_DUAL_PORT;
+		else
+			gpio |= GPIOR_UHD_SNGL_PORT;
+		writel(gpio, priv->regs + GPIOR);
+	} else
+		cntl |= CR1_OPS_LCD24;
+	writel(cntl, priv->regs + CR1);
+
+	drm_panel_enable(priv->panel);
+	drm_crtc_vblank_on(crtc);
+}
+
+void baikal_vdu_crtc_helper_disable(struct drm_crtc *crtc)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	drm_panel_disable(priv->panel);
+
+	drm_panel_unprepare(priv->panel);
+	drm_crtc_vblank_off(crtc);
+
+	/* Disable clock */
+	DRM_DEV_DEBUG_DRIVER(crtc->dev->dev, "disabling pixel clock\n");
+	clk_disable_unprepare(priv->clk);
+}
+
+static void baikal_vdu_crtc_helper_atomic_flush(struct drm_crtc *crtc,
+					   struct drm_crtc_state *old_state)
+{
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+	if (event) {
+		crtc->state->event = NULL;
+
+		spin_lock_irq(&crtc->dev->event_lock);
+		if (crtc->state->active && drm_crtc_vblank_get(crtc) == 0)
+			drm_crtc_arm_vblank_event(crtc, event);
+		else
+			drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+	}
+}
+
+int baikal_vdu_enable_vblank(struct drm_crtc *crtc)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	/* clear interrupt status */
+	writel(0x3ffff, priv->regs + ISR);
+
+	writel(INTR_VCT + INTR_FER, priv->regs + IMR);
+
+	return 0;
+}
+
+void baikal_vdu_disable_vblank(struct drm_crtc *crtc)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	/* clear interrupt status */
+	writel(0x3ffff, priv->regs + ISR);
+
+	writel(INTR_FER, priv->regs + IMR);
+}
+
+const struct drm_crtc_funcs crtc_funcs = {
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.destroy = drm_crtc_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = baikal_vdu_enable_vblank,
+	.disable_vblank = baikal_vdu_disable_vblank,
+};
+
+const struct drm_crtc_helper_funcs crtc_helper_funcs = {
+	.mode_fixup = baikal_vdu_crtc_mode_fixup,
+	.mode_set_nofb = baikal_vdu_crtc_helper_mode_set_nofb,
+	.atomic_flush = baikal_vdu_crtc_helper_atomic_flush,
+	.disable = baikal_vdu_crtc_helper_disable,
+	.atomic_enable = baikal_vdu_crtc_helper_enable,
+};
+
+int baikal_vdu_crtc_create(struct drm_device *dev)
+{
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_crtc *crtc = &priv->crtc;
+
+	drm_crtc_init_with_planes(dev, crtc,
+				  &priv->primary, NULL,
+				  &crtc_funcs, "primary");
+	drm_crtc_helper_add(crtc, &crtc_helper_funcs);
+
+	/* XXX: The runtime clock disabling still results in
+	 * occasional system hangs, and needs debugging.
+	 */
+
+	DRM_DEV_DEBUG_DRIVER(crtc->dev->dev, "enabling pixel clock\n");
+	clk_prepare_enable(priv->clk);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_debugfs.c b/drivers/gpu/drm/baikal/baikal_vdu_debugfs.c
new file mode 100644
index 000000000000..fd4d31ca7afd
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_debugfs.c
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ *  Copyright © 2017 Broadcom
+ */
+
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <drm/drm_debugfs.h>
+#include <drm/drm_device.h>
+#include <drm/drm_file.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+#define REGDEF(reg) { reg, #reg }
+static const struct {
+	u32 reg;
+	const char *name;
+} baikal_vdu_reg_defs[] = {
+	REGDEF(CR1),
+	REGDEF(HTR),
+	REGDEF(VTR1),
+	REGDEF(VTR2),
+	REGDEF(PCTR),
+	REGDEF(ISR),
+	REGDEF(IMR),
+	REGDEF(IVR),
+	REGDEF(ISCR),
+	REGDEF(DBAR),
+	REGDEF(DCAR),
+	REGDEF(DEAR),
+	REGDEF(HVTER),
+	REGDEF(HPPLOR),
+	REGDEF(GPIOR),
+	REGDEF(OWER),
+	REGDEF(OWXSER0),
+	REGDEF(OWYSER0),
+	REGDEF(OWDBAR0),
+	REGDEF(OWDCAR0),
+	REGDEF(OWDEAR0),
+	REGDEF(OWXSER1),
+	REGDEF(OWYSER1),
+	REGDEF(OWDBAR1),
+	REGDEF(OWDCAR1),
+	REGDEF(OWDEAR1),
+	REGDEF(MRR),
+};
+
+int baikal_vdu_debugfs_regs(struct seq_file *m, void *unused)
+{
+	struct drm_info_node *node = (struct drm_info_node *)m->private;
+	struct drm_device *dev = node->minor->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(baikal_vdu_reg_defs); i++) {
+		seq_printf(m, "%s (0x%04x): 0x%08x\n",
+			   baikal_vdu_reg_defs[i].name, baikal_vdu_reg_defs[i].reg,
+			   readl(priv->regs + baikal_vdu_reg_defs[i].reg));
+	}
+
+	for (i = 0; i < ARRAY_SIZE(priv->counters); i++) {
+		seq_printf(m, "COUNTER[%d]: 0x%08x\n", i, priv->counters[i]);
+	}
+
+	return 0;
+}
+
+static ssize_t baikal_vdu_rg_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *filename = file->f_path.dentry->d_iname;
+	struct baikal_vdu_private *priv = file->f_inode->i_private;
+	char buf[16];
+	int len = 0;
+
+	if (!strcmp("htr", filename))
+		len = snprintf(buf, sizeof(buf), "%x\n", readl(priv->regs + HTR));
+	else if (!strcmp("vtr", filename))
+		len = snprintf(buf, sizeof(buf), "%x\n", readl(priv->regs + VTR1));
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t baikal_vdu_rg_write(struct file *file,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+	struct baikal_vdu_private *priv = file->f_inode->i_private;
+	char *filename = file->f_path.dentry->d_iname;
+	u32 val;
+	int ret;
+
+	ret = kstrtouint_from_user(buf, count, 16, &val);
+	if (ret)
+		return ret;
+
+	if (!strcmp("htr", filename))
+		writel(val, priv->regs + HTR);
+	else if (!strcmp("vtr", filename))
+		writel(val, priv->regs + VTR1);
+
+	return count;
+}
+
+static const struct file_operations baikal_vdu_rg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.write = baikal_vdu_rg_write,
+	.read = baikal_vdu_rg_read,
+};
+
+static const struct drm_info_list baikal_vdu_debugfs_list[] = {
+	{"regs", baikal_vdu_debugfs_regs, 0},
+};
+
+int baikal_vdu_debugfs_init(struct drm_minor *minor)
+{
+	struct drm_device *dev = minor->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	debugfs_create_file("htr", S_IWUSR, minor->debugfs_root, priv, &baikal_vdu_rg_fops);
+	debugfs_create_file("vtr", S_IWUSR, minor->debugfs_root, priv, &baikal_vdu_rg_fops);
+	return drm_debugfs_create_files(baikal_vdu_debugfs_list,
+					ARRAY_SIZE(baikal_vdu_debugfs_list),
+					minor->debugfs_root, minor);
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_drm.h b/drivers/gpu/drm/baikal/baikal_vdu_drm.h
new file mode 100644
index 000000000000..d9caa46bc1b1
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_drm.h
@@ -0,0 +1,67 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+#ifndef __BAIKAL_VDU_DRM_H__
+#define __BAIKAL_VDU_DRM_H__
+
+#include <drm/drm_gem.h>
+#include <drm/drm_simple_kms_helper.h>
+#include <linux/workqueue.h>
+
+/* Append new drm mode definition here, align with libdrm definition */
+#define DRM_MODE_SCALE_NO_SCALE	2
+
+#define VDU_TYPE_HDMI	0
+#define VDU_TYPE_LVDS	1
+
+#define to_baikal_vdu_private(x) \
+	container_of(x, struct baikal_vdu_private, connector)
+
+struct baikal_vdu_private {
+	struct drm_device *drm;
+	struct drm_crtc crtc;
+	struct drm_connector connector;
+	struct drm_encoder encoder;
+	struct drm_panel *panel;
+	struct drm_bridge *bridge;
+	struct drm_plane primary;
+	void *regs;
+	struct clk *clk;
+	spinlock_t lock;
+	u32 counters[20];
+	int mode_fixup;
+	int type;
+	int ep_count;
+	u32 fb_addr;
+	u32 fb_end;
+	struct delayed_work update_work;
+};
+
+
+/* CRTC Functions */
+int baikal_vdu_crtc_create(struct drm_device *dev);
+irqreturn_t baikal_vdu_irq(int irq, void *data);
+
+int baikal_vdu_primary_plane_init(struct drm_device *dev);
+
+/* Connector Functions */
+int baikal_vdu_lvds_connector_create(struct drm_device *dev);
+
+/* Debugfs functions */
+int baikal_vdu_debugfs_init(struct drm_minor *minor);
+
+/* Worker functions */
+void baikal_vdu_update_work(struct work_struct *work);
+
+#endif /* __BAIKAL_VDU_DRM_H__ */
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_drv.c b/drivers/gpu/drm/baikal/baikal_vdu_drv.c
new file mode 100644
index 000000000000..ddbb8df53b12
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_drv.c
@@ -0,0 +1,394 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ * All bugs by Alexey Sheplyakov <asheplyakov@altlinux.org>
+ *
+ * This driver is based on ARM PL111 DRM driver
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/version.h>
+#include <linux/shmem_fs.h>
+#include <linux/dma-buf.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_irq.h>
+#include <drm/drm_of.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_vblank.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+#define DRIVER_NAME                 "baikal-vdu"
+#define DRIVER_DESC                 "DRM module for Baikal VDU"
+#define DRIVER_DATE                 "20210129"
+
+#define BAIKAL_SMC_SCP_LOG_DISABLE  0x82000200
+
+int mode_fixup = 0;
+
+static struct drm_mode_config_funcs mode_config_funcs = {
+	.fb_create = drm_gem_fb_create,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+const struct drm_encoder_funcs baikal_vdu_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+/* Walks the OF graph to find the endpoint node and then asks DRM
+ * to look up the panel or the bridge connected to the node found
+ */
+int baikal_vdu_find_panel_or_bridge(struct device *dev,
+		struct drm_panel **panel, struct drm_bridge **bridge)
+{
+	struct device_node *endpoint = NULL;
+	struct device_node *remote;
+	struct device_node *old_remote = NULL;
+	struct device_node *np = dev->of_node;
+	struct drm_device *drm = dev_get_drvdata(dev);
+	struct baikal_vdu_private *priv = drm->dev_private;
+	int ep_count = 0;
+
+	for_each_endpoint_of_node(np, endpoint) {
+
+		remote = of_graph_get_remote_port_parent(endpoint);
+		if (old_remote && remote != old_remote) {
+			dev_err(dev, "all endpoints must be connected to the same panel or bridge %d\n", ep_count);
+			of_node_put(endpoint);
+			return -EINVAL;
+		}
+
+		/* don't proceed if we have an endpoint but no panel node
+		 * or bridge node tied to it */
+		if (!remote) {
+			dev_err(dev, "no valid remote node connected to the endpoint@%d\n", ep_count);
+			of_node_put(endpoint);
+			return -EINVAL;
+		}
+
+		ep_count++;
+		of_node_put(remote);
+		old_remote = remote;
+	}
+
+	if (!ep_count) {
+		dev_err(dev, "no endpoints found connected either to panel or bridge\n");
+		return -EINVAL;
+	}
+
+	if (!of_device_is_available(remote)) {
+		dev_err(dev, "not available for remote node\n");
+		return -EINVAL;
+	}
+
+	priv->ep_count = ep_count;
+
+	return drm_of_find_panel_or_bridge(np, 0, 0, panel, bridge);
+
+}
+
+static int baikal_vdu_remove_efifb(struct drm_device *dev)
+{
+	int err;
+	struct apertures_struct *a;
+	a = alloc_apertures(1);
+	if (!a) {
+		err = -ENOMEM;
+		dev_warn(dev->dev, "failed to allocate apertures\n");
+		goto out;
+	}
+	a->ranges[0].base = 0;
+	a->ranges[0].size = ~0;
+	err = drm_fb_helper_remove_conflicting_framebuffers(a, "baikal-vdudrmfb", false);
+	if (err) {
+		dev_warn(dev->dev, "failed to remove firmware framebuffer\n");
+	}
+	kfree(a);
+out:
+	return err;
+}
+
+static int vdu_modeset_init(struct drm_device *dev)
+{
+	struct drm_mode_config *mode_config;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_encoder *encoder;
+	struct arm_smccc_res res;
+	int ret = 0;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	drm_mode_config_init(dev);
+	mode_config = &dev->mode_config;
+	mode_config->funcs = &mode_config_funcs;
+	mode_config->min_width = 1;
+	mode_config->max_width = 4095;
+	mode_config->min_height = 1;
+	mode_config->max_height = 4095;
+
+	ret = baikal_vdu_primary_plane_init(dev);
+	if (ret != 0) {
+		dev_err(dev->dev, "Failed to init primary plane\n");
+		goto out_config;
+	}
+
+	ret = baikal_vdu_crtc_create(dev);
+	if (ret) {
+		dev_err(dev->dev, "Failed to create crtc\n");
+		goto out_config;
+	}
+
+	ret = baikal_vdu_find_panel_or_bridge(dev->dev, &priv->panel, &priv->bridge);
+	if (ret == -EPROBE_DEFER) {
+		dev_info(dev->dev, "Bridge probe deferred\n");
+		goto out_config;
+	}
+
+	if (priv->bridge) {
+		encoder = &priv->encoder;
+		ret = drm_encoder_init(dev, encoder, &baikal_vdu_encoder_funcs,
+				       DRM_MODE_ENCODER_NONE, NULL);
+		if (ret) {
+			dev_err(dev->dev, "Failed to create DRM encoder\n");
+			goto out_config;
+		}
+		encoder->crtc = &priv->crtc;
+		encoder->possible_crtcs = BIT(drm_crtc_index(encoder->crtc));
+		priv->bridge->encoder = encoder;
+		encoder->bridge = priv->bridge;
+		ret = drm_bridge_attach(encoder, priv->bridge, NULL);
+		if (ret) {
+			dev_err(dev->dev, "Failed to attach DRM bridge %d\n", ret);
+			goto out_config;
+		}
+	} else if (priv->panel) {
+		ret = baikal_vdu_lvds_connector_create(dev);
+		if (ret) {
+			dev_err(dev->dev, "Failed to create DRM connector\n");
+			goto out_config;
+		}
+	} else
+		ret = -EINVAL;
+
+	if (ret) {
+		dev_err(dev->dev, "No bridge or panel attached!\n");
+		goto out_config;
+	}
+
+	priv->clk = clk_get(dev->dev, "pclk");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev->dev, "fatal: unable to get pclk, err %ld\n", PTR_ERR(priv->clk));
+		ret = PTR_ERR(priv->clk);
+		goto out_config;
+	}
+
+	priv->mode_fixup = mode_fixup;
+
+	baikal_vdu_remove_efifb(dev);
+
+	ret = drm_vblank_init(dev, 1);
+	if (ret != 0) {
+		dev_err(dev->dev, "Failed to init vblank\n");
+		goto out_clk;
+	}
+
+	arm_smccc_smc(BAIKAL_SMC_SCP_LOG_DISABLE, 0, 0, 0, 0, 0, 0, 0, &res);
+	INIT_DEFERRABLE_WORK(&priv->update_work,
+			     baikal_vdu_update_work);
+
+	drm_mode_config_reset(dev);
+
+	drm_kms_helper_poll_init(dev);
+
+	ret = drm_dev_register(dev, 0);
+	if (ret)
+		goto out_clk;
+
+	drm_fbdev_generic_setup(dev, 32);
+	goto finish;
+
+out_clk:
+	clk_put(priv->clk);
+out_config:
+	drm_mode_config_cleanup(dev);
+finish:
+	return ret;
+}
+
+static const struct file_operations drm_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.release = drm_release,
+	.unlocked_ioctl = drm_ioctl,
+	.mmap = drm_gem_cma_mmap,
+	.poll = drm_poll,
+	.read = drm_read,
+};
+
+static struct drm_driver vdu_drm_driver = {
+	.driver_features = DRIVER_GEM |	DRIVER_MODESET | DRIVER_ATOMIC,
+	.lastclose = drm_fb_helper_lastclose,
+	.irq_handler = baikal_vdu_irq,
+	.ioctls = NULL,
+	.fops = &drm_fops,
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = 1,
+	.minor = 0,
+	.patchlevel = 0,
+	.dumb_create = drm_gem_cma_dumb_create,
+	.dumb_destroy = drm_gem_dumb_destroy,
+	.dumb_map_offset = drm_gem_dumb_map_offset,
+	.gem_free_object_unlocked = drm_gem_cma_free_object,
+	.gem_vm_ops = &drm_gem_cma_vm_ops,
+
+	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+	.gem_prime_import = drm_gem_prime_import,
+	.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
+	.gem_prime_export = drm_gem_prime_export,
+	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table,
+	.gem_prime_mmap = drm_gem_cma_prime_mmap,
+	.gem_prime_vmap = drm_gem_cma_prime_vmap,
+
+#if defined(CONFIG_DEBUG_FS)
+	.debugfs_init = baikal_vdu_debugfs_init,
+#endif
+};
+
+static int baikal_vdu_drm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct baikal_vdu_private *priv;
+	struct drm_device *drm;
+	struct resource *mem;
+	int irq;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->fb_end = 0;
+
+	drm = drm_dev_alloc(&vdu_drm_driver, dev);
+	if (IS_ERR(drm))
+		return PTR_ERR(drm);
+	platform_set_drvdata(pdev, drm);
+	priv->drm = drm;
+	drm->dev_private = priv;
+
+	if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0))) {
+		dev_err(dev, "%s no MMIO resource specified\n", __func__);
+		return -EINVAL;
+	}
+
+	priv->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(priv->regs)) {
+		dev_err(dev, "%s MMIO allocation failed\n", __func__);
+		return PTR_ERR(priv->regs);
+	}
+
+	/* turn off interrupts before requesting the irq */
+	writel(0, priv->regs + IMR);
+
+	if (!(irq = platform_get_irq(pdev, 0))) {
+		dev_err(dev, "%s no IRQ resource specified\n", __func__);
+		return -EINVAL;
+	}
+
+	spin_lock_init(&priv->lock);
+
+	ret = drm_irq_install(drm, irq);
+	if (ret != 0) {
+		dev_err(dev, "%s IRQ %d allocation failed\n", __func__, irq);
+		return ret;
+	}
+
+	if (pdev->dev.of_node && of_property_read_bool(pdev->dev.of_node, "lvds-out"))
+		priv->type = VDU_TYPE_LVDS;
+	else
+		priv->type = VDU_TYPE_HDMI;
+
+	ret = vdu_modeset_init(drm);
+	if (ret != 0) {
+		dev_err(dev, "Failed to init modeset\n");
+		goto dev_unref;
+	}
+
+	return 0;
+
+dev_unref:
+	writel(0, priv->regs + IMR);
+	writel(0x3ffff, priv->regs + ISR);
+	drm_irq_uninstall(drm);
+	drm->dev_private = NULL;
+	drm_dev_put(drm);
+	return ret;
+}
+
+static int baikal_vdu_drm_remove(struct platform_device *pdev)
+{
+	struct drm_device *drm = platform_get_drvdata(pdev);
+
+	drm_dev_unregister(drm);
+	drm_mode_config_cleanup(drm);
+	drm_irq_uninstall(drm);
+	drm->dev_private = NULL;
+	drm_dev_put(drm);
+
+	return 0;
+}
+
+static const struct of_device_id baikal_vdu_of_match[] = {
+	{ .compatible = "baikal,vdu" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, baikal_vdu_of_match);
+
+static struct platform_driver baikal_vdu_platform_driver = {
+	.probe  = baikal_vdu_drm_probe,
+	.remove = baikal_vdu_drm_remove,
+	.driver = {
+		.name   = DRIVER_NAME,
+		.of_match_table = baikal_vdu_of_match,
+	},
+};
+
+module_param(mode_fixup, int, 0644);
+
+module_platform_driver(baikal_vdu_platform_driver);
+
+MODULE_AUTHOR("Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>");
+MODULE_DESCRIPTION("Baikal Electronics BE-M1000 Video Display Unit (VDU) DRM Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
+MODULE_SOFTDEP("pre: baikal_hdmi");
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_plane.c b/drivers/gpu/drm/baikal/baikal_vdu_plane.c
new file mode 100644
index 000000000000..26617386855b
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_plane.c
@@ -0,0 +1,193 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_graph.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+#define BAIKAL_SMC_VDU_UPDATE	0x82000100
+
+void baikal_vdu_update_work(struct work_struct *work)
+{
+	struct arm_smccc_res res;
+	unsigned long flags;
+	struct baikal_vdu_private *priv = container_of(work, struct baikal_vdu_private,
+			update_work.work);
+	int count = 0;
+	u64 t1, t2;
+	t1 = read_sysreg(CNTVCT_EL0);
+	spin_lock_irqsave(&priv->lock, flags);
+	arm_smccc_smc(BAIKAL_SMC_VDU_UPDATE, priv->fb_addr, priv->fb_end, 0, 0, 0, 0, 0, &res);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	if (res.a0 == -EBUSY)
+		priv->counters[15]++;
+	else
+		priv->counters[16]++;
+	while (res.a0 == -EBUSY && count < 10) {
+		count++;
+		usleep_range(10000, 20000);
+		res.a0 = 0;
+		spin_lock_irqsave(&priv->lock, flags);
+		arm_smccc_smc(BAIKAL_SMC_VDU_UPDATE, priv->fb_addr, priv->fb_end, 0, 0, 0, 0, 0, &res);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		if (res.a0 == -EBUSY)
+			priv->counters[15]++;
+		else
+			priv->counters[16]++;
+	}
+	t2 = read_sysreg(CNTVCT_EL0);
+	priv->counters[17] = t2 - t1;
+	priv->counters[18] = count;
+	priv->counters[19]++;
+}
+
+static void baikal_vdu_primary_plane_atomic_update(struct drm_plane *plane,
+					      struct drm_plane_state *old_state)
+{
+	struct drm_device *dev = plane->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_plane_state *state = plane->state;
+	struct drm_framebuffer *fb = state->fb;
+	struct arm_smccc_res res;
+	uint32_t cntl;
+	uint32_t addr;
+	uint32_t end;
+	unsigned long flags;
+
+	if (!fb)
+		return;
+
+	addr = drm_fb_cma_get_gem_addr(fb, state, 0);
+	end = ((addr + fb->height * fb->pitches[0] - 1) & MRR_DEAR_MRR_MASK) | MRR_OUTSTND_RQ(4);
+	if (priv->panel)
+		addr |= 1;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	arm_smccc_smc(BAIKAL_SMC_VDU_UPDATE, addr, end, 0, 0, 0, 0, 0, &res);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	if (res.a0 == -EBUSY) {
+		priv->counters[15]++;
+		priv->fb_addr = addr;
+		priv->fb_end = end;
+		smp_wmb();
+		schedule_delayed_work(&priv->update_work, usecs_to_jiffies(250));
+	} else
+		priv->counters[16]++;
+
+	cntl = readl(priv->regs + CR1);
+	cntl &= ~CR1_BPP_MASK;
+
+	/* Note that the the hardware's format reader takes 'r' from
+	 * the low bit, while DRM formats list channels from high bit
+	 * to low bit as you read left to right.
+	 */
+	switch (fb->format->format) {
+	case DRM_FORMAT_BGR888:
+		cntl |= CR1_BPP24 | CR1_FBP | CR1_BGR;
+		break;
+	case DRM_FORMAT_RGB888:
+		cntl |= CR1_BPP24 | CR1_FBP;
+		break;
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_XBGR8888:
+		cntl |= CR1_BPP24 | CR1_BGR;
+		break;
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XRGB8888:
+		cntl |= CR1_BPP24;
+		break;
+	case DRM_FORMAT_BGR565:
+		cntl |= CR1_BPP16_565 | CR1_BGR;
+		break;
+	case DRM_FORMAT_RGB565:
+		cntl |= CR1_BPP16_565;
+		break;
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_XBGR1555:
+		cntl |= CR1_BPP16_555 | CR1_BGR;
+		break;
+	case DRM_FORMAT_ARGB1555:
+	case DRM_FORMAT_XRGB1555:
+		cntl |= CR1_BPP16_555;
+		break;
+	default:
+		WARN_ONCE(true, "Unknown FB format 0x%08x, set XRGB8888 instead\n",
+				fb->format->format);
+		cntl |= CR1_BPP24;
+		break;
+	}
+
+	writel(cntl, priv->regs + CR1);
+}
+
+static const struct drm_plane_helper_funcs baikal_vdu_primary_plane_helper_funcs = {
+	.atomic_update = baikal_vdu_primary_plane_atomic_update,
+	.prepare_fb = drm_gem_fb_prepare_fb,
+};
+
+static const struct drm_plane_funcs baikal_vdu_primary_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.reset = drm_atomic_helper_plane_reset,
+	.destroy = drm_plane_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+int baikal_vdu_primary_plane_init(struct drm_device *drm)
+{
+	struct baikal_vdu_private *priv = drm->dev_private;
+	struct drm_plane *plane = &priv->primary;
+	static const u32 formats[] = {
+		DRM_FORMAT_BGR888,
+		DRM_FORMAT_RGB888,
+		DRM_FORMAT_ABGR8888,
+		DRM_FORMAT_XBGR8888,
+		DRM_FORMAT_ARGB8888,
+		DRM_FORMAT_XRGB8888,
+		DRM_FORMAT_BGR565,
+		DRM_FORMAT_RGB565,
+		DRM_FORMAT_ABGR1555,
+		DRM_FORMAT_XBGR1555,
+		DRM_FORMAT_ARGB1555,
+		DRM_FORMAT_XRGB1555,
+	};
+	int ret;
+
+	ret = drm_universal_plane_init(drm, plane, 0,
+				       &baikal_vdu_primary_plane_funcs,
+				       formats,
+				       ARRAY_SIZE(formats),
+				       NULL,
+				       DRM_PLANE_TYPE_PRIMARY,
+				       NULL);
+	if (ret)
+		return ret;
+
+	drm_plane_helper_add(plane, &baikal_vdu_primary_plane_helper_funcs);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_regs.h b/drivers/gpu/drm/baikal/baikal_vdu_regs.h
new file mode 100644
index 000000000000..5553fcac5fec
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_regs.h
@@ -0,0 +1,139 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ *   David A Rusling
+ *   Copyright (C) 2001 ARM Limited
+ */
+
+#ifndef __BAIKAL_VDU_REGS_H__
+#define __BAIKAL_VDU_REGS_H__
+
+#define CR1         0x000
+#define HTR         0x008
+#define VTR1        0x00C
+#define VTR2        0x010
+#define PCTR        0x014
+#define ISR         0x018
+#define IMR         0x01C
+#define IVR         0x020
+#define ISCR        0x024
+#define DBAR        0x028
+#define DCAR        0x02C
+#define DEAR        0x030
+#define HVTER       0x044
+#define HPPLOR      0x048
+#define GPIOR       0x1F8
+#define OWER        0x600
+#define OWXSER0     0x604
+#define OWYSER0     0x608
+#define OWDBAR0     0x60C
+#define OWDCAR0     0x610
+#define OWDEAR0     0x614
+#define OWXSER1     0x618
+#define OWYSER1     0x61C
+#define OWDBAR1     0x620
+#define OWDCAR1     0x624
+#define OWDEAR1     0x628
+#define MRR         0xFFC
+
+#define INTR_BAU    BIT(7)
+#define INTR_VCT    BIT(6)
+#define INTR_MBE    BIT(5)
+#define INTR_FER    BIT(4)
+
+#define CR1_FBP             BIT(19)
+#define CR1_FDW_MASK        GENMASK(17, 16)
+#define CR1_FDW_4_WORDS     (0 << 16)
+#define CR1_FDW_8_WORDS     (1 << 16)
+#define CR1_FDW_16_WORDS    (2 << 16)
+#define CR1_OPS_LCD18       (0 << 13)
+#define CR1_OPS_LCD24       (1 << 13)
+#define CR1_OPS_565         (0 << 12)
+#define CR1_OPS_555         (1 << 12)
+#define CR1_VSP             BIT(11)
+#define CR1_HSP             BIT(10)
+#define CR1_DEP             BIT(8)
+#define CR1_BGR             BIT(5)
+#define CR1_BPP_MASK        GENMASK(4, 2)
+#define CR1_BPP1            (0 << 2)
+#define CR1_BPP2            (1 << 2)
+#define CR1_BPP4            (2 << 2)
+#define CR1_BPP8            (3 << 2)
+#define CR1_BPP16           (4 << 2)
+#define CR1_BPP18           (5 << 2)
+#define CR1_BPP24           (6 << 2)
+#define CR1_LCE             BIT(0)
+
+#define CR1_BPP16_555 ((CR1_BPP16) | (CR1_OPS_555))
+#define CR1_BPP16_565 ((CR1_BPP16) | (CR1_OPS_565))
+
+#define VTR1_VBP_MASK       GENMASK(23, 16)
+#define VTR1_VBP(x)         ((x) << 16)
+#define VTR1_VBP_LSB_WIDTH  8
+#define VTR1_VFP_MASK       GENMASK(15, 8)
+#define VTR1_VFP(x)         ((x) << 8)
+#define VTR1_VFP_LSB_WIDTH  8
+#define VTR1_VSW_MASK       GENMASK(7, 0)
+#define VTR1_VSW(x)         ((x) << 0)
+#define VTR1_VSW_LSB_WIDTH  8
+
+#define VTR2_LPP_MASK       GENMASK(11, 0)
+
+#define HTR_HSW_MASK        GENMASK(31, 24)
+#define HTR_HSW(x)          ((x) << 24)
+#define HTR_HSW_LSB_WIDTH   8
+#define HTR_HBP_MASK        GENMASK(23, 16)
+#define HTR_HBP(x)          ((x) << 16)
+#define HTR_HBP_LSB_WIDTH   8
+#define HTR_PPL_MASK        GENMASK(15, 8)
+#define HTR_PPL(x)          ((x) << 8)
+#define HTR_HFP_MASK        GENMASK(7, 0)
+#define HTR_HFP(x)          ((x) << 0)
+#define HTR_HFP_LSB_WIDTH   8
+
+#define PCTR_PCI2           BIT(11)
+#define PCTR_PCR            BIT(10)
+#define PCTR_PCI            BIT(9)
+#define PCTR_PCB            BIT(8)
+#define PCTR_PCD_MASK       GENMASK(7, 0)
+#define PCTR_MAX_PCD        128
+
+#define ISCR_VSC_OFF        0x0
+#define ISCR_VSC_VSW        0x4
+#define ISCR_VSC_VBP        0x5
+#define ISCR_VSC_VACTIVE    0x6
+#define ISCR_VSC_VFP        0x7
+
+#define HVTER_VSWE_MASK     GENMASK(25, 24)
+#define HVTER_VSWE(x)       ((x) << 24)
+#define HVTER_HSWE_MASK     GENMASK(17, 16)
+#define HVTER_HSWE(x)       ((x) << 16)
+#define HVTER_VBPE_MASK     GENMASK(13, 12)
+#define HVTER_VBPE(x)       ((x) << 12)
+#define HVTER_VFPE_MASK     GENMASK(9, 8)
+#define HVTER_VFPE(x)       ((x) << 8)
+#define HVTER_HBPE_MASK     GENMASK(5, 4)
+#define HVTER_HBPE(x)       ((x) << 4)
+#define HVTER_HFPE_MASK     GENMASK(1, 0)
+#define HVTER_HFPE(x)       ((x) << 0)
+
+#define HPPLOR_HPOE         BIT(31)
+#define HPPLOR_HPPLO_MASK   GENMASK(11, 0)
+#define HPPLOR_HPPLO(x)     ((x) << 0)
+
+#define GPIOR_UHD_MASK      GENMASK(23, 16)
+#define GPIOR_UHD_SNGL_PORT (0 << 18)
+#define GPIOR_UHD_DUAL_PORT (1 << 18)
+#define GPIOR_UHD_QUAD_PORT (2 << 18)
+#define GPIOR_UHD_ENB       BIT(17)
+
+#define MRR_DEAR_MRR_MASK   GENMASK(31, 3)
+#define MRR_OUTSTND_RQ_MASK GENMASK(2, 0)
+#define MRR_OUTSTND_RQ(x)   ((x >> 1) << 0)
+
+#endif /* __BAIKAL_VDU_REGS_H__ */
-- 
2.33.0

